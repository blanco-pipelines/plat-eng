# Terraform Drift Detection and Fix

## Overview
In this lab, you will learn how to detect and fix infrastructure drift using Terraform state commands. Drift occurs when your actual infrastructure differs from what Terraform expects based on its state file.

## Learning Objectives
- Understand what drift is and why it happens
- Detect drift using `terraform plan`
- Use `terraform state` commands to inspect and manage state
- Fix drift by refreshing state or updating resources
- Handle resources that were manually deleted or modified

## Prerequisites
- Completed previous labs
- AWS credentials configured
- Terraform installed

## What is Drift?

**Drift** happens when someone or something changes your infrastructure outside of Terraform:
- Manual changes in AWS Console
- Changes made by other automation tools
- Resources deleted manually
- Tags added/removed outside Terraform

Terraform tracks infrastructure in its **state file**. When reality doesn't match the state file, you have drift.

## Setup

### Create the Lab Directory

1. In **Visual Studio Code**, open your terraform directory.
2. Right-click in the **Explorer** pane and select **New Folder**.
3. Name the folder `tf-drift`.
4. Right-click `tf-drift` and select **Open in Integrated Terminal**.

## Part 1: Create Initial Infrastructure

### Create main.tf

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-west-1"
}

# Data source for AMI
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# Default VPC
data "aws_vpc" "default" {
  default = true
}

# Default subnets
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# Security group
resource "aws_security_group" "drift_sg" {
  name        = "drift-demo-sg"
  description = "Security group for drift demo"
  vpc_id      = data.aws_vpc.default.id

  ingress {
    description = "SSH"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "drift-demo-sg"
    Environment = "dev"
    ManagedBy   = "Terraform"
  }
}

# EC2 instance
resource "aws_instance" "drift_server" {
  ami                    = data.aws_ami.amazon_linux.id
  instance_type          = "t2.micro"
  subnet_id              = element(tolist(data.aws_subnets.default.ids), 0)
  vpc_security_group_ids = [aws_security_group.drift_sg.id]

  tags = {
    Name        = "drift-demo-server"
    Environment = "dev"
    ManagedBy   = "Terraform"
  }
}

# S3 bucket
resource "aws_s3_bucket" "drift_bucket" {
  bucket = "drift-demo-bucket-${formatdate("YYYYMMDDhhmmss", timestamp())}"

  tags = {
    Name        = "drift-demo-bucket"
    Environment = "dev"
    ManagedBy   = "Terraform"
  }
}
```

### Create outputs.tf

```hcl
output "instance_id" {
  value = aws_instance.drift_server.id
}

output "instance_public_ip" {
  value = aws_instance.drift_server.public_ip
}

output "security_group_id" {
  value = aws_security_group.drift_sg.id
}

output "bucket_name" {
  value = aws_s3_bucket.drift_bucket.id
}
```

### Deploy Infrastructure

```sh
terraform init
terraform apply
```

Type `yes` to confirm. Note the output values - you'll need them later.

## Part 2: Understanding Terraform State Commands

Before we create drift, let's explore state commands.

### List All Resources

```sh
terraform state list
```

You'll see:
```
data.aws_ami.amazon_linux
data.aws_subnets.default
data.aws_vpc.default
aws_instance.drift_server
aws_s3_bucket.drift_bucket
aws_security_group.drift_sg
```

### Show Specific Resource Details

```sh
terraform state show aws_instance.drift_server
```

This displays all attributes Terraform knows about the instance.

### Show Another Resource

```sh
terraform state show aws_s3_bucket.drift_bucket
```

Notice all the details Terraform tracks.

## Part 3: Create Drift - Manual Tag Changes

Now let's cause drift by making manual changes in AWS Console.

### Modify Tags in AWS Console

1. Go to the **EC2 Console** in your browser
2. Find your instance (`drift-demo-server`)
3. Select it and click **Tags** tab
4. **Add a new tag:**
   - Key: `Owner`
   - Value: `John Doe`
5. **Modify existing tag:**
   - Change `Environment` from `dev` to `production`
6. Click **Save**

### Detect the Drift

Back in your terminal, run:

```sh
terraform plan
```

**Important observation:** Terraform detects the drift! You'll see:
```
~ tags = {
    + "Owner"       = "John Doe"
    ~ "Environment" = "dev" -> "production"
  }
```

The `~` means change detected, `+` means added, `-` would mean removed.

### Refresh State

You can update Terraform's state to match reality without applying changes:

```sh
terraform refresh
```

Now run plan again:
```sh
terraform plan
```

The drift is still there! `terraform refresh` alone doesn't fix drift - it just updates Terraform's knowledge. To fix, you need to apply.

### Fix Drift by Applying

```sh
terraform apply
```

This will change the tags back to what's defined in your code:
- Remove the `Owner` tag
- Change `Environment` back to `dev`

Type `yes` to confirm.

Verify in AWS Console - tags are back to Terraform's definition!

## Part 4: Create Drift - Manual Resource Deletion

Now let's see what happens when someone deletes a resource.

### Delete S3 Bucket Manually

1. Go to **S3 Console**
2. Find your bucket (name is in outputs: `terraform output bucket_name`)
3. **Empty the bucket** (required before deletion)
4. **Delete the bucket**

### Detect Missing Resource

```sh
terraform plan
```

Terraform detects the bucket is missing and wants to recreate it:
```
# aws_s3_bucket.drift_bucket will be created
```

### Recreate the Resource

```sh
terraform apply
```

Type `yes`. Terraform recreates the missing bucket.

## Part 5: Remove Resource from State (Without Deleting)

Sometimes you want Terraform to "forget" about a resource without deleting it.

### Remove Instance from State

```sh
terraform state rm aws_instance.drift_server
```

Output: `Removed aws_instance.drift_server`

### Verify Removal

```sh
terraform state list
```

The instance is no longer in the list!

### Check What Terraform Wants to Do

```sh
terraform plan
```

Terraform wants to create a **new** instance because it doesn't know about the existing one.

**Important:** The actual EC2 instance still exists in AWS! We only removed it from Terraform's state.

### Re-Import the Instance

To bring the existing instance back under Terraform management:

```sh
terraform import aws_instance.drift_server <YOUR_INSTANCE_ID>
```

Replace `<YOUR_INSTANCE_ID>` with the actual instance ID (check AWS Console or the output you saved earlier).

Example:
```sh
terraform import aws_instance.drift_server i-0123456789abcdef0
```

### Verify Import

```sh
terraform state list
```

The instance is back!

```sh
terraform plan
```

Terraform now knows about the instance again. You might see tag differences - apply to sync:

```sh
terraform apply
```

## Part 6: Move Resources in State

Sometimes you need to rename resources in your code. Use `terraform state mv` to update the state without recreating resources.

### Rename Security Group in Code

In `main.tf`, change the resource name from `drift_sg` to `demo_sg`:

```hcl
resource "aws_security_group" "demo_sg" {  # Changed from drift_sg
  name        = "drift-demo-sg"
  # ... rest stays the same
}
```

Also update the reference in the instance:

```hcl
resource "aws_instance" "drift_server" {
  # ...
  vpc_security_group_ids = [aws_security_group.demo_sg.id]  # Changed
  # ...
}
```

And in outputs.tf:

```hcl
output "security_group_id" {
  value = aws_security_group.demo_sg.id  # Changed
}
```

### See What Happens Without Moving

```sh
terraform plan
```

Oh no! Terraform wants to:
- Destroy `aws_security_group.drift_sg`
- Create `aws_security_group.demo_sg`

This would cause downtime!

### Cancel and Fix with State Move

Don't apply! Instead, use `terraform state mv`:

```sh
terraform state mv aws_security_group.drift_sg aws_security_group.demo_sg
```

Output: `Successfully moved 1 object(s).`

### Verify No Changes Needed

```sh
terraform plan
```

No changes! Terraform now tracks the same security group under the new name.

## Part 7: State Command Reference

### Commonly Used Commands

```sh
# List all resources in state
terraform state list

# Show details of a specific resource
terraform state show <resource_address>

# Remove a resource from state (doesn't delete actual resource)
terraform state rm <resource_address>

# Move/rename a resource in state
terraform state mv <source> <destination>

# Import existing resource into state
terraform import <resource_address> <resource_id>

# Update state with real infrastructure (detect drift)
terraform refresh

# Pull and display entire state (JSON format)
terraform state pull
```

## Part 8: Preventing Drift

### Best Practices

1. **Use Policy Enforcement** - Restrict AWS Console access for managed resources
2. **Tag Resources Clearly** - Use `ManagedBy = "Terraform"` tags
3. **Regular Drift Detection** - Run `terraform plan` regularly in CI/CD
4. **Use lifecycle Rules** - Protect critical resources:
   ```hcl
   lifecycle {
     prevent_destroy = true
   }
   ```
5. **Centralized State** - Use remote state (S3) so team sees same state
6. **Documentation** - Make it clear which resources are Terraform-managed

## Cleanup

Destroy all resources:

```sh
terraform destroy
```

Type `yes` to confirm.

Verify in AWS Console that resources are gone.

## Common Scenarios and Solutions

### Scenario 1: Tags Changed Manually
**Solution:** Run `terraform apply` to restore defined tags

### Scenario 2: Resource Deleted Manually
**Solution:** Run `terraform apply` to recreate the resource

### Scenario 3: Need to Stop Managing a Resource
**Solution:** Use `terraform state rm` then manually manage it

### Scenario 4: Resource Exists but Not in State
**Solution:** Use `terraform import` to bring it under management

### Scenario 5: Renamed Resource in Code
**Solution:** Use `terraform state mv` to update state without recreation

## Summary

You learned:
- ✅ What drift is and how it happens
- ✅ How to detect drift with `terraform plan`
- ✅ Using `terraform state list` and `show` to inspect state
- ✅ Fixing drift by reapplying configuration
- ✅ Using `terraform state rm` to remove resources from state
- ✅ Using `terraform import` to add existing resources to state
- ✅ Using `terraform state mv` to rename resources
- ✅ Best practices for preventing drift

## Important Notes

⚠️ **State commands are powerful and can break things!** Always:
- Backup state before using state commands
- Use version control for state (remote backends)
- Test state commands in dev before production
- Understand what each command does

# Congrats!
You now know how to detect and fix infrastructure drift with Terraform!
