# Terraform Resource Dependencies

## Overview
In this lab, you will learn how Terraform manages dependencies between resources and how to control resource creation and destruction order. Understanding dependencies is critical for building reliable infrastructure.

## Learning Objectives
- Understand implicit dependencies through resource references
- Use explicit dependencies with `depends_on`
- Control resource lifecycle with lifecycle rules
- Troubleshoot common dependency issues

## Prerequisites
- Completed Day 1 and Day 2 labs
- AWS credentials configured
- Terraform installed

## Setup

### Create the Lab Directory

1. In **Visual Studio Code**, open your working directory.
2. Right-click in the **Explorer** pane and select **New Folder**.
3. Name the folder `tf-lab6`.
4. Right-click `tf-lab6` and select **Open in Integrated Terminal**.

## Part 1: Implicit Dependencies

Terraform automatically detects dependencies when one resource references another. This is the **preferred** way to manage dependencies.

### Create Configuration with Implicit Dependencies

Create a `main.tf` file:

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-west-1"
}

# Create a VPC
resource "aws_vpc" "lab_vpc" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "lab6-vpc"
  }
}

# Create a subnet - implicitly depends on VPC
resource "aws_subnet" "lab_subnet" {
  vpc_id                  = aws_vpc.lab_vpc.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "us-west-1b"
  map_public_ip_on_launch = true

  tags = {
    Name = "lab6-subnet"
  }
}

# Create an internet gateway - implicitly depends on VPC
resource "aws_internet_gateway" "lab_igw" {
  vpc_id = aws_vpc.lab_vpc.id

  tags = {
    Name = "lab6-igw"
  }
}
```

### Apply and Observe

1. Initialize Terraform:
   ```sh
   terraform init
   ```

2. Run a plan and observe the order:
   ```sh
   terraform plan
   ```

Notice that Terraform automatically determined the creation order:
- VPC first
- Subnet and Internet Gateway second (both depend on VPC)

3. Apply the configuration:
   ```sh
   terraform apply
   ```

4. Type `yes` to confirm.

**Key Point:** You didn't need to tell Terraform about dependencies. The reference `aws_vpc.lab_vpc.id` automatically created the dependency.

## Part 2: Explicit Dependencies

Sometimes you need to enforce a dependency that Terraform can't detect automatically. Use `depends_on` for these cases.

### Add Resources with Explicit Dependencies

Add the following to your `main.tf`:

```hcl
# Create a route table
resource "aws_route_table" "lab_rt" {
  vpc_id = aws_vpc.lab_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.lab_igw.id
  }

  tags = {
    Name = "lab6-rt"
  }
}

# Associate route table with subnet
resource "aws_route_table_association" "lab_rta" {
  subnet_id      = aws_subnet.lab_subnet.id
  route_table_id = aws_route_table.lab_rt.id
}

# Security group
resource "aws_security_group" "lab_sg" {
  name        = "lab6-sg"
  description = "Lab 6 security group"
  vpc_id      = aws_vpc.lab_vpc.id

  ingress {
    description = "SSH from anywhere"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "lab6-sg"
  }
}

# EC2 instance with explicit dependency
resource "aws_instance" "lab_instance" {
  ami                    = "ami-06e4ca05d431835e9"
  instance_type          = "t2.micro"
  subnet_id              = aws_subnet.lab_subnet.id
  vpc_security_group_ids = [aws_security_group.lab_sg.id]

  # Explicit dependency: ensure internet gateway is ready before launching instance
  depends_on = [aws_internet_gateway.lab_igw]

  tags = {
    Name = "lab6-instance"
  }
}
```

### Apply and Observe

```sh
terraform apply
```

**Question:** Why use `depends_on` for the internet gateway?
- The instance doesn't directly reference the IGW
- But the instance needs internet connectivity on launch (for updates, etc.)
- `depends_on` ensures the IGW exists before the instance launches

## Part 3: Lifecycle Rules

Lifecycle rules control how Terraform creates, updates, and destroys resources.

### Create Before Destroy

Some resources should be created before destroying the old one (to avoid downtime).

Add this to your EC2 instance:

```hcl
resource "aws_instance" "lab_instance" {
  ami                    = "ami-06e4ca05d431835e9"
  instance_type          = "t2.micro"
  subnet_id              = aws_subnet.lab_subnet.id
  vpc_security_group_ids = [aws_security_group.lab_sg.id]

  depends_on = [aws_internet_gateway.lab_igw]

  lifecycle {
    create_before_destroy = true
  }

  tags = {
    Name = "lab6-instance"
  }
}
```

Now try changing the AMI:

```hcl
  ami                    = "ami-0d902a8756c37e690"
```

Run `terraform apply` and observe:
- Terraform creates the NEW instance first
- Then destroys the OLD instance
- This minimizes downtime

Change it back to `ami-06e4ca05d431835e9` and apply again.

### Prevent Destroy

Some resources are too critical to accidentally destroy. Add protection:

Add a new resource to `main.tf`:

```hcl
# S3 bucket for important data
resource "aws_s3_bucket" "important_data" {
  bucket = "lab6-important-data-${formatdate("YYYYMMDDhhmmss", timestamp())}"

  lifecycle {
    prevent_destroy = true
  }

  tags = {
    Name        = "lab6-critical-bucket"
    Environment = "production"
  }
}
```

Apply this change:
```sh
terraform apply
```

Now try to destroy it:
```sh
terraform destroy
```

You'll see an error! Terraform refuses to destroy resources with `prevent_destroy = true`.

**To proceed with cleanup**, you'll need to either:
- Remove the lifecycle rule
- Comment out the resource
- Use `terraform state rm` to remove it from state

For this lab, let's comment out the lifecycle block:

```hcl
resource "aws_s3_bucket" "important_data" {
  bucket = "lab6-important-data-${formatdate("YYYYMMDDhhmmss", timestamp())}"

  # lifecycle {
  #   prevent_destroy = true
  # }

  tags = {
    Name        = "lab6-critical-bucket"
    Environment = "production"
  }
}
```

Apply the change:
```sh
terraform apply
```

### Ignore Changes

Sometimes you want Terraform to ignore changes made outside of Terraform.

Add another resource:

```hcl
# EC2 instance that might be manually tagged
resource "aws_instance" "flexible_instance" {
  ami                    = "ami-06e4ca05d431835e9"
  instance_type          = "t2.micro"
  subnet_id              = aws_subnet.lab_subnet.id
  vpc_security_group_ids = [aws_security_group.lab_sg.id]

  lifecycle {
    ignore_changes = [tags]
  }

  tags = {
    Name = "lab6-flexible"
  }
}
```

Apply:
```sh
terraform apply
```

Now, if someone manually adds tags via the AWS Console, Terraform won't try to remove them on the next apply.

## Part 4: Visualizing Dependencies

Terraform can show you the dependency graph:

```sh
terraform graph
```

This outputs a DOT format graph. To visualize it:

1. Copy the output
2. Visit: https://dreampuf.github.io/GraphvizOnline/
3. Paste the DOT output
4. See your infrastructure dependency graph!

## Common Dependency Patterns

### Pattern 1: Chain Dependencies
```hcl
A → B → C
```
Each resource depends on the previous one.

### Pattern 2: Fan-Out Dependencies
```hcl
    A
   / \
  B   C
```
Multiple resources depend on one.

### Pattern 3: Fan-In Dependencies
```hcl
  A   B
   \ /
    C
```
One resource depends on multiple.

## Best Practices

1. **Prefer implicit dependencies** - Use resource references instead of `depends_on`
2. **Use `depends_on` sparingly** - Only when implicit dependencies aren't possible
3. **Use `create_before_destroy`** - For resources that need zero downtime
4. **Use `prevent_destroy`** - For stateful resources (databases, S3 buckets with data)
5. **Avoid circular dependencies** - Terraform will error if A depends on B and B depends on A

## Troubleshooting

### Circular Dependency Error
```
Error: Cycle: aws_instance.a, aws_security_group.b
```
**Solution:** Refactor to break the cycle, often by splitting resources or using separate apply steps.

### Resource Not Ready
If a resource is used before it's fully ready, add an explicit `depends_on`.

### Destroy Fails
Check for dependencies that need to be destroyed first. Terraform usually handles this, but manual changes can cause issues.

## Cleanup

Remove all resources:

```sh
terraform destroy
```

Type `yes` to confirm.

Verify all resources are deleted in the AWS Console.

## Summary

You learned:
- ✅ Implicit dependencies through resource references (preferred method)
- ✅ Explicit dependencies with `depends_on` (when needed)
- ✅ `create_before_destroy` for zero-downtime updates
- ✅ `prevent_destroy` for protecting critical resources
- ✅ `ignore_changes` for flexible resource management
- ✅ How to visualize dependency graphs

## Challenge (Optional)

Create a configuration that demonstrates all three lifecycle rules on different resources in a single configuration. Think about realistic use cases for each.

# Congrats!
You now understand how Terraform manages resource dependencies and lifecycles!
