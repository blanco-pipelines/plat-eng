# Terraform Functions

## Overview
In this lab, you will learn how to use Terraform's built-in functions to make your configurations more dynamic and flexible. Functions help you manipulate strings, numbers, lists, and maps without writing custom code.

## Learning Objectives
- Use string manipulation functions
- Work with collection functions (lists and maps)
- Apply type conversion functions
- Use the Terraform console for testing functions

## Prerequisites
- Completed previous labs
- AWS credentials configured
- Terraform installed

## What are Functions?

Terraform includes many built-in functions that you can use in expressions. Functions are called with the syntax `function_name(argument1, argument2, ...)`.

**Important:** You cannot create your own functions in Terraform. You must use the built-in functions provided.

## Setup

### Create the Lab Directory

1. In **Visual Studio Code**, open your working directory (`YYYYMMDD/terraform`).
2. Right-click in the **Explorer** pane and select **New Folder**.
3. Name the folder `tf-functions`.
4. Right-click `tf-functions` and select **Open in Integrated Terminal**.

## Part 1: Using the Terraform Console

The Terraform console is an interactive environment for testing expressions and functions.

### Create a Basic Configuration

First, create a minimal `main.tf` so the console has context:

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-west-1"
}
```

Initialize Terraform:
```sh
terraform init
```

### Open the Console

```sh
terraform console
```

You'll see a `>` prompt. Now you can test any Terraform expression or function!

Try a simple expression:
```
> 1 + 1
2
```

Type `exit` to leave the console (we'll come back to it).

## Part 2: String Functions

Let's explore common string manipulation functions.

### upper() and lower()

Create a `variables.tf` file:

```hcl
variable "environment" {
  description = "Environment name"
  type        = string
  default     = "development"
}

variable "project_name" {
  description = "Project name"
  type        = string
  default     = "MyApp"
}
```

Create an `outputs.tf` file:

```hcl
# Convert to uppercase
output "env_upper" {
  value = upper(var.environment)
}

# Convert to lowercase
output "project_lower" {
  value = lower(var.project_name)
}

# Combine both
output "resource_name" {
  value = "${lower(var.project_name)}-${upper(var.environment)}"
}
```

Apply and see the results:
```sh
terraform apply
```

You'll see:
- `env_upper = "DEVELOPMENT"`
- `project_lower = "myapp"`
- `resource_name = "myapp-DEVELOPMENT"`

### format() and formatdate()

Add to `outputs.tf`:

```hcl
# Format strings with placeholders
output "formatted_message" {
  value = format("Welcome to %s environment for project %s", var.environment, var.project_name)
}

# Format the current timestamp
output "current_time" {
  value = formatdate("YYYY-MM-DD hh:mm:ss", timestamp())
}
```

Apply again:
```sh
terraform apply
```

**Note:** The timestamp will change each apply, which Terraform will detect. This is expected behavior.

## Part 3: Collection Functions - Lists

Now let's work with lists.

Add to `variables.tf`:

```hcl
variable "availability_zones" {
  description = "List of availability zones"
  type        = list(string)
  default     = ["us-west-1a", "us-west-1b", "us-west-1c"]
}

variable "instance_counts" {
  description = "Number of instances per zone"
  type        = list(number)
  default     = [2, 3, 1]
}
```

Add to `outputs.tf`:

```hcl
# Get the length of a list
output "az_count" {
  value = length(var.availability_zones)
}

# Get a specific element (first one, index 0)
output "first_az" {
  value = element(var.availability_zones, 0)
}

# Join list items into a string
output "all_azs" {
  value = join(", ", var.availability_zones)
}

# Combine two lists
output "combined_info" {
  value = zipmap(var.availability_zones, var.instance_counts)
}
```

Apply:
```sh
terraform apply
```

You'll see:
- `az_count = 3`
- `first_az = "us-west-1a"`
- `all_azs = "us-west-1a, us-west-1b, us-west-1c"`
- `combined_info = { "us-west-1a" = 2, "us-west-1b" = 3, "us-west-1c" = 1 }`

## Part 4: Collection Functions - Maps

Let's work with maps (key-value pairs).

Add to `variables.tf`:

```hcl
variable "tags" {
  description = "Resource tags"
  type        = map(string)
  default = {
    Environment = "dev"
    Project     = "terraform-lab"
    ManagedBy   = "Terraform"
  }
}

variable "additional_tags" {
  description = "Additional tags"
  type        = map(string)
  default = {
    Owner = "DevOps Team"
    CostCenter = "Engineering"
  }
}
```

Add to `outputs.tf`:

```hcl
# Get all keys from a map
output "tag_keys" {
  value = keys(var.tags)
}

# Get all values from a map
output "tag_values" {
  value = values(var.tags)
}

# Merge two maps
output "all_tags" {
  value = merge(var.tags, var.additional_tags)
}

# Lookup a specific key
output "environment_tag" {
  value = lookup(var.tags, "Environment", "unknown")
}
```

Apply:
```sh
terraform apply
```

## Part 5: Numeric and Type Functions

Add to `outputs.tf`:

```hcl
# Maximum value
output "max_instances" {
  value = max(var.instance_counts...)
}

# Minimum value
output "min_instances" {
  value = min(var.instance_counts...)
}

# Convert to string
output "first_count_as_string" {
  value = tostring(var.instance_counts[0])
}

# Convert list to set (removes duplicates)
output "unique_zones" {
  value = toset(var.availability_zones)
}
```

Apply:
```sh
terraform apply
```

## Part 6: Practical Example - EC2 with Functions

Now let's use functions in a real resource. Update `main.tf`:

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-west-1"
}

# Data source for AMI
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# Default VPC
data "aws_vpc" "default" {
  default = true
}

# Default subnets
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# EC2 instance using functions
resource "aws_instance" "example" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = "t2.micro"
  subnet_id     = element(tolist(data.aws_subnets.default.ids), 0)

  # Use functions to create dynamic tags
  tags = merge(
    var.tags,
    var.additional_tags,
    {
      Name = format("%s-%s-server", lower(var.project_name), var.environment)
      CreatedAt = formatdate("YYYY-MM-DD", timestamp())
      AZ = element(var.availability_zones, 0)
    }
  )
}
```

Add output for the instance:

```hcl
output "instance_id" {
  value = aws_instance.example.id
}

output "instance_name" {
  value = aws_instance.example.tags["Name"]
}
```

Apply:
```sh
terraform apply
```

Check the AWS Console - see how the instance tags were created using functions!

## Part 7: Testing Functions in Console

Open the Terraform console again:
```sh
terraform console
```

Try these examples:

### String Functions
```
> upper("hello world")
"HELLO WORLD"

> lower("TERRAFORM")
"terraform"

> title("hello world")
"Hello World"

> format("Instance: %s in %s", "web-server", "us-west-1")
"Instance: web-server in us-west-1"
```

### List Functions
```
> length(["a", "b", "c"])
3

> element(["first", "second", "third"], 1)
"second"

> concat(["a", "b"], ["c", "d"])
["a", "b", "c", "d"]

> join("-", ["terraform", "lab", "example"])
"terraform-lab-example"
```

### Map Functions
```
> lookup({name = "test", env = "dev"}, "name", "default")
"test"

> keys({a = 1, b = 2, c = 3})
["a", "b", "c"]

> merge({a = 1}, {b = 2})
{
  "a" = 1
  "b" = 2
}
```

### Numeric Functions
```
> max(5, 12, 9)
12

> min(5, 12, 9)
5

> ceil(5.3)
6

> floor(5.9)
5
```

Type `exit` when done.

## Common Functions Reference

### String Functions
- `upper(string)` - Convert to uppercase
- `lower(string)` - Convert to lowercase
- `title(string)` - Capitalize first letter of each word
- `format(spec, values...)` - Format string with placeholders
- `join(separator, list)` - Join list elements into string
- `split(separator, string)` - Split string into list

### Collection Functions
- `length(collection)` - Get number of items
- `element(list, index)` - Get element at index
- `concat(lists...)` - Combine multiple lists
- `merge(maps...)` - Combine multiple maps
- `lookup(map, key, default)` - Get value from map with fallback
- `keys(map)` - Get all keys from map
- `values(map)` - Get all values from map
- `zipmap(keys, values)` - Create map from two lists

### Numeric Functions
- `max(numbers...)` - Return largest number
- `min(numbers...)` - Return smallest number
- `ceil(number)` - Round up
- `floor(number)` - Round down

### Type Conversion Functions
- `tostring(value)` - Convert to string
- `tonumber(value)` - Convert to number
- `tobool(value)` - Convert to boolean
- `tolist(value)` - Convert to list
- `toset(value)` - Convert to set (removes duplicates)
- `tomap(value)` - Convert to map

## Best Practices

1. **Use functions to avoid hardcoding values** - Make your configuration flexible
2. **Test in the console first** - Try functions before using them in resources
3. **Keep it readable** - Don't nest too many functions; break complex logic into locals
4. **Use descriptive variable names** - Makes function usage clearer

## Cleanup

Destroy the test infrastructure:
```sh
terraform destroy
```

Type `yes` to confirm.

## Summary

You learned:
- ✅ How to use the Terraform console for testing
- ✅ String manipulation functions
- ✅ Working with lists and maps
- ✅ Type conversion functions
- ✅ Practical application in real resources
- ✅ Common function reference

## Resources

For the complete function reference, visit:
https://developer.hashicorp.com/terraform/language/functions

# Congrats!
You now know how to use Terraform functions to create dynamic configurations!
