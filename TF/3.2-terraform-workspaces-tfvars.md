# Terraform Workspaces

## Overview
In this lab, you will learn how to use Terraform workspaces to manage multiple environments (dev and production) with a single configuration.

## Learning Objectives
- Understand Terraform workspaces
- Create and switch between workspaces
- Reference the current workspace in your code
- Manage isolated state per environment

## Prerequisites
- Completed labs 3.1 (Resource Dependencies)
- AWS credentials configured
- Terraform installed

## What are Workspaces?

Workspaces allow you to manage multiple instances of the same infrastructure with separate state files. Common use cases:
- **Development** and **Production** environments
- **Feature branches** for testing
- **Multi-region** deployments

Each workspace has its own state file, so changes in one workspace don't affect others.

## Setup

### Create the Lab Directory

1. In **Visual Studio Code**, open your terraform working directory.
2. Right-click in the **Explorer** pane and select **New Folder**.
3. Name the folder `tf-workspaces`.
4. Right-click `tf-workspaces` and select **Open in Integrated Terminal**.

## Part 1: Understanding Default Workspace

Every Terraform configuration starts with a workspace called `default`.

### List Current Workspaces

```sh
terraform workspace list
```

You'll see:
```
* default
```

The `*` indicates the currently active workspace.

### Show Current Workspace

```sh
terraform workspace show
```

Output: `default`

## Part 2: Create Environment Configuration

Let's create infrastructure that adapts based on the workspace.

### Create variables.tf

```hcl
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-west-1"
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t2.micro"
}
```

### Create main.tf

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# Data source for latest Amazon Linux 2 AMI
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# Default VPC
data "aws_vpc" "default" {
  default = true
}

# Default subnets
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# Security group with workspace-aware naming
resource "aws_security_group" "app_sg" {
  name        = "workspaces-${terraform.workspace}-sg"
  description = "Security group for ${terraform.workspace} workspace"
  vpc_id      = data.aws_vpc.default.id

  ingress {
    description = "SSH access"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name      = "workspaces-${terraform.workspace}-sg"
    Workspace = terraform.workspace
  }
}

# EC2 instance with workspace-aware configuration
resource "aws_instance" "app_server" {
  ami                    = data.aws_ami.amazon_linux.id
  instance_type          = var.instance_type
  subnet_id              = element(tolist(data.aws_subnets.default.ids), 0)
  vpc_security_group_ids = [aws_security_group.app_sg.id]

  tags = {
    Name      = "workspaces-${terraform.workspace}-server"
    Workspace = terraform.workspace
  }
}
```

### Create outputs.tf

```hcl
output "workspace_name" {
  description = "Current workspace name"
  value       = terraform.workspace
}

output "instance_id" {
  description = "ID of created instance"
  value       = aws_instance.app_server.id
}

output "instance_public_ip" {
  description = "Public IP of created instance"
  value       = aws_instance.app_server.public_ip
}

output "security_group_id" {
  description = "Security group ID"
  value       = aws_security_group.app_sg.id
}
```

## Part 3: Create Environment-Specific Variable Files

Now create different `.tfvars` files for each environment.

### Create dev.tfvars

```hcl
instance_type = "t2.micro"
```

### Create prod.tfvars

```hcl
instance_type = "t2.small"
```

## Part 4: Working with Workspaces

### Initialize Terraform

```sh
terraform init
```

### Create Development Workspace

```sh
terraform workspace new dev
```

Output:
```
Created and switched to workspace "dev"!
```

### List Workspaces

```sh
terraform workspace list
```

Output:
```
  default
* dev
```

### Deploy to Development

```sh
terraform apply -var-file="dev.tfvars"
```

Review the plan:
- 1 t2.micro instance
- Resources tagged with workspace name "dev"

Type `yes` to apply.

### View Outputs

```sh
terraform output
```

You'll see:
- Workspace: `dev`
- Instance ID and IP

## Part 5: Create and Deploy to Production

### Create Production Workspace

```sh
terraform workspace new prod
```

### Deploy to Production

```sh
terraform apply -var-file="prod.tfvars"
```

Review the plan:
- 1 t2.small instance
- Production workspace tag

Type `yes` to apply.

## Part 6: Switching Between Workspaces

### Switch Back to Dev

```sh
terraform workspace select dev
```

### View Dev Resources

```sh
terraform output
```

You'll see only the dev environment resources.

### Compare Environments

Switch between workspaces and compare outputs:

```sh
terraform workspace select dev
terraform output instance_public_ip

terraform workspace select prod
terraform output instance_public_ip
```

Each workspace maintains separate state and resources!

## Part 7: Workspace-Specific State Files

Terraform stores workspace states in the `.terraform` directory:

```sh
ls .terraform/terraform.tfstate.d/
```

You'll see directories for each workspace:
```
dev/
prod/
```

Each contains its own `terraform.tfstate` file.

## Part 8: Using Workspace Name in Configuration

The `terraform.workspace` variable is useful for dynamic naming. You've already seen it in action in the resource names and tags.

### View Resources in AWS Console

Go to the EC2 console and look at your instances. You'll see:
- `workspaces-dev-server`
- `workspaces-prod-server`

All clearly labeled by workspace!

## Part 9: Best Practices

### 1. Naming Convention
Always include workspace name in resource names to avoid conflicts:
```hcl
name = "${terraform.workspace}-${var.environment}-resource"
```

### 2. Use tfvars Files
Keep configuration differences in separate `.tfvars` files for each workspace.

### 3. Don't Use Default Workspace for Production
Reserve `default` for testing. Use named workspaces for real environments.

### 4. Validate Before Switching
Always check which workspace you're in:
```sh
terraform workspace show
```

### 5. Document Your Workspaces
Keep a README with workspace names and purposes.

## Common Workspace Commands

```sh
# List all workspaces
terraform workspace list

# Show current workspace
terraform workspace show

# Create and switch to new workspace
terraform workspace new <name>

# Switch to existing workspace
terraform workspace select <name>

# Delete workspace (must be empty)
terraform workspace delete <name>
```

## Cleanup

Clean up each environment separately.

### Destroy Dev

```sh
terraform workspace select dev
terraform destroy -var-file="dev.tfvars"
```

Type `yes` to confirm.

### Destroy Production

```sh
terraform workspace select prod
terraform destroy -var-file="prod.tfvars"
```

Type `yes` to confirm.

### Delete Workspaces (Optional)

After destroying resources, you can delete the workspaces:

```sh
terraform workspace select default
terraform workspace delete dev
terraform workspace delete prod
```

## Real-World Considerations

### When to Use Workspaces

✅ **Good use cases:**
- Multiple environments in the same account
- Testing infrastructure changes
- Short-lived feature environments

❌ **Not recommended for:**
- Production vs Non-Production (use separate state backends instead)
- Multiple teams (use separate configurations)
- Different AWS accounts (use separate configurations with different providers)

### Alternative: Separate Configurations

For production systems, consider separate directories:
```
infrastructure/
  dev/
    main.tf
    terraform.tfstate
  prod/
    main.tf
    terraform.tfstate
```

This provides stronger isolation than workspaces.

## Summary

You learned:
- ✅ Create and manage Terraform workspaces
- ✅ Use workspace-specific `.tfvars` files
- ✅ Reference `terraform.workspace` in configurations
- ✅ Maintain isolated state per workspace
- ✅ Switch between environments safely
- ✅ Best practices for workspace usage

## Challenge (Optional)

1. Create a workspace called `test`
2. Deploy with minimal resources (keep default t2.micro)
3. Switch between all workspaces and compare the infrastructure
4. Clean up the test workspace

# Congrats!
You now know how to manage multiple environments with Terraform workspaces!
