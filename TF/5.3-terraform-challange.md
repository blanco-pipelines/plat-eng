# Final Terraform Challenge: Enterprise VPC Module with Testing

## Overview

This is your final Terraform challenge. You will combine everything you've learned throughout the course to build, test, publish, and deploy a production-ready VPC module. This challenge requires you to:

1. **Create a reusable VPC module** with customizable networking components
2. **Write comprehensive unit and integration tests** for your module
3. **Publish the module to HCP Terraform's private registry** with proper versioning
4. **Consume your module** in a parent configuration to deploy a working multi-tier application
5. **Validate connectivity** between public and private subnets

This challenge mirrors real-world scenarios where infrastructure engineers create reusable, tested modules for their organizations.

---

## Challenge Requirements

### Part 1: Create a Custom VPC Module (30 minutes)

#### 1.1 Module Repository Setup

Create a new GitHub repository following the Terraform module naming convention:
- Repository name: `terraform-aws-vpc-{your-initials}`
- Initialize with a README.md

#### 1.2 Module Functionality

Your VPC module must support the following features:

**Network Architecture:**
- Configurable VPC CIDR block
- Variable number of public subnets across multiple availability zones
- Variable number of private subnets across multiple availability zones
- Internet Gateway for public subnet connectivity
- NAT Gateway(s) for private subnet internet access
- Appropriate route tables and associations

**Required Variables:**
- `vpc_name` - Name tag for the VPC
- `vpc_cidr` - CIDR block for the VPC (e.g., "10.0.0.0/16")
- `availability_zones` - List of AZs to use (e.g., ["us-east-1a", "us-east-1b"])
- `public_subnet_cidrs` - List of CIDR blocks for public subnets
- `private_subnet_cidrs` - List of CIDR blocks for private subnets
- `enable_nat_gateway` - Boolean to enable/disable NAT gateway
- `single_nat_gateway` - Boolean to use one NAT gateway for all private subnets (cost saving) or one per AZ (high availability)
- `enable_dns_hostnames` - Boolean to enable DNS hostnames in the VPC
- `enable_dns_support` - Boolean to enable DNS support in the VPC
- `tags` - Map of common tags to apply to all resources

**Required Outputs:**
- `vpc_id` - The VPC ID
- `vpc_cidr_block` - The VPC CIDR block
- `public_subnet_ids` - List of public subnet IDs
- `private_subnet_ids` - List of private subnet IDs
- `nat_gateway_ids` - List of NAT Gateway IDs
- `internet_gateway_id` - The Internet Gateway ID
- `public_route_table_ids` - List of public route table IDs
- `private_route_table_ids` - List of private route table IDs

**Module Structure:**
```
terraform-aws-vpc-{your-initials}/
├── main.tf           # VPC, subnets, gateways, route tables
├── variables.tf      # All input variables with descriptions and validation
├── outputs.tf        # All outputs with descriptions
├── versions.tf       # Terraform and provider version constraints
├── README.md         # Module documentation
├── tests/
│   ├── unit_tests.tftest.hcl           # Unit tests
│   ├── integration_tests.tftest.hcl    # Integration tests
│   └── setup/
│       └── main.tf   # Test setup configuration (mock provider, etc.)
└── examples/
    └── complete/
        ├── main.tf   # Example usage of the module
        └── README.md # Example documentation
```

**Tips for Implementation:**
- Use `count` or `for_each` to create multiple subnets dynamically
- Use `cidrsubnet()` function if you want to calculate subnet CIDRs automatically (optional)
- Consider using `zipmap()` or `for` expressions to create useful data structures
- Add validation rules to your variables (e.g., CIDR format, minimum subnet count)

---

### Part 2: Write Comprehensive Tests (20 minutes)

#### 2.1 Unit Tests (`tests/unit_tests.tftest.hcl`)

Create unit tests that validate:

**Test 1: VPC Creation with Minimal Configuration**
- Verify VPC is created with correct CIDR
- Verify DNS settings are applied correctly
- Test with 1 public and 1 private subnet

**Test 2: Multi-AZ Deployment**
- Test with 2 public and 2 private subnets across different AZs
- Verify correct number of subnets are created
- Verify subnets are in correct AZs

**Test 3: NAT Gateway Configuration**
- Test `enable_nat_gateway = true` with `single_nat_gateway = true`
- Verify only one NAT gateway is planned
- Test `enable_nat_gateway = true` with `single_nat_gateway = false`
- Verify NAT gateways match the number of public subnets

**Test 4: NAT Gateway Disabled**
- Test `enable_nat_gateway = false`
- Verify no NAT gateways are planned

**Test 5: Variable Validation**
- Test invalid CIDR block (should fail validation)
- Test mismatched subnet count vs AZ count (should fail or warn)

**Test 6: Tagging**
- Verify tags are applied to all resources
- Test custom tag propagation

#### 2.2 Integration Tests (`tests/integration_tests.tftest.hcl`)

Create integration tests that actually deploy infrastructure (these will use mock AWS credentials in test mode, but structure them as if deploying real resources):

**Integration Test 1: Full Deployment**
- Deploy a complete VPC with 2 AZs, 2 public subnets, 2 private subnets
- Verify all outputs are returned correctly
- Verify route tables have correct routes
- Clean up resources

**Integration Test 2: Network Connectivity**
- Verify public subnets have route to Internet Gateway
- Verify private subnets have route to NAT Gateway (when enabled)
- Verify route table associations are correct

---

### Part 3: Publish Module to HCP Terraform (10 minutes)

#### 3.1 Version and Publish

1. **Create Initial Release:**
   - Tag your repository with version `1.0.0`
   - Push the tag to trigger HCP Terraform registry publishing

2. **Connect to HCP Terraform:**
   - In HCP Terraform, navigate to Registry → Modules
   - Add your VCS connection if not already configured
   - Publish your `terraform-aws-vpc-{your-initials}` module
   - Verify version 1.0.0 appears in the registry

3. **Update Documentation:**
   - Ensure your README.md has clear usage examples
   - Include input/output tables
   - Add example configurations

---

### Part 4: Consume Module in Parent Configuration (30 minutes)

#### 4.1 Create Parent Configuration Repository

Create a new repository: `terraform-aws-app-{your-initials}`

This configuration will:
- Use your published VPC module
- Deploy EC2 instances in both public and private subnets
- Configure security groups for SSH access
- Test connectivity between instances

#### 4.2 Required Parent Configuration Components

**Provider and Backend:**
```hcl
# Configure HCP Terraform backend
# Use appropriate AWS provider version
```

**VPC Module Call:**
- Use your published module from HCP Terraform private registry
- Configure with 2 AZs, 2 public subnets, 2 private subnets
- Enable NAT gateway with single NAT for cost savings

**Security Groups:**

Create security groups for:
1. **Public Instance Security Group:**
   - Allow SSH (port 22) from your IP address
   - Allow outbound to private subnet on all ports

2. **Private Instance Security Group:**
   - Allow SSH (port 22) from public subnet CIDR
   - Allow ICMP (ping) from public subnet CIDR
   - Allow outbound internet access (for package installation)

**EC2 Instances:**

Deploy two EC2 instances:
1. **Bastion/Jump Host (Public Subnet):**
   - Amazon Linux 2 or Ubuntu
   - Instance type: t2.micro or t3.micro
   - Deploy in first public subnet
   - Associate public IP
   - Use your existing key pair or create a new one

2. **Application Server (Private Subnet):**
   - Amazon Linux 2 or Ubuntu
   - Instance type: t2.micro or t3.micro
   - Deploy in first private subnet
   - No public IP
   - Use the same key pair

**Outputs:**
```hcl
# Output the public IP of the bastion host
# Output the private IP of the application server
# Output connection instructions
```

#### 4.3 HCP Terraform Workspace

- Create a new HCP Terraform workspace for this deployment
- Configure AWS credentials as workspace environment variables
- Link to your VCS repository (optional) or use CLI workflow

---

### Part 5: Validate Connectivity (15 minutes)

#### 5.1 SSH to Bastion Host

1. After deployment, retrieve the bastion host public IP from Terraform outputs
2. SSH to the bastion host:
   ```bash
   ssh -i /path/to/your-key.pem ec2-user@<bastion-public-ip>
   # or ubuntu@<bastion-public-ip> if using Ubuntu
   ```

#### 5.2 Test Private Instance Connectivity

From the bastion host, test connectivity to the private instance:

1. **Ping Test:**
   ```bash
   ping <private-instance-ip>
   ```
   You should see successful ping responses.

2. **SSH to Private Instance:**
   ```bash
   ssh -i /path/to/your-key.pem ec2-user@<private-instance-ip>
   # or ubuntu@<private-instance-ip> if using Ubuntu
   ```

   **Note:** For this to work, you need to have the SSH key on the bastion host. You can:
   - Use SSH agent forwarding: `ssh -A -i /path/to/your-key.pem ec2-user@<bastion-public-ip>`
   - Or copy the key to the bastion (less secure, not recommended for production)

3. **Test Internet Connectivity from Private Instance:**
   
   Once logged into the private instance:
   ```bash
   # Test DNS resolution
   nslookup google.com
   
   # Test internet connectivity through NAT gateway
   curl -I https://www.google.com
   
   # Try installing a package (tests both internet and DNS)
   sudo yum update -y  # Amazon Linux
   # or
   sudo apt update     # Ubuntu
   ```

#### 5.3 Document Your Results

Create a file `VALIDATION.md` in your parent configuration repository documenting:
- Screenshot or output of successful SSH connection to bastion
- Screenshot or output of successful SSH from bastion to private instance
- Screenshot or output of successful internet connectivity from private instance
- Screenshot or output of successful ping between instances
- Any troubleshooting steps you had to take

---

## Success Criteria

You have successfully completed the challenge when:

- [ ] VPC module repository created with correct naming convention
- [ ] VPC module implements all required variables and outputs
- [ ] All six unit tests pass successfully (`terraform test` shows all pass)
- [ ] Both integration tests are implemented (even if mock deployment)
- [ ] Module is published to HCP Terraform private registry at version 1.0.0
- [ ] Module documentation is complete with usage examples
- [ ] Parent configuration successfully uses the published module
- [ ] Parent configuration deploys bastion host in public subnet
- [ ] Parent configuration deploys application server in private subnet
- [ ] Security groups correctly configured for SSH access
- [ ] Successfully SSH into bastion host from your local machine
- [ ] Successfully ping private instance from bastion host
- [ ] Successfully SSH into private instance from bastion host
- [ ] Private instance can access the internet through NAT gateway
- [ ] All Terraform code follows best practices (proper formatting, clear variable names, comments where needed)
- [ ] Validation results documented in VALIDATION.md

---

## Deliverables

Submit the following:

1. **VPC Module Repository URL** (`terraform-aws-vpc-{your-initials}`)
   - Include all module files and tests
   - Must be tagged at version 1.0.0

2. **Parent Configuration Repository URL** (`terraform-aws-app-{your-initials}`)
   - Include all Terraform configuration files
   - Include VALIDATION.md with connectivity test results

3. **HCP Terraform Screenshots:**
   - Screenshot of module in private registry
   - Screenshot of successful workspace run

4. **Test Results:**
   - Output of `terraform test` showing all tests passing

---

## Bonus Challenges (Optional)

If you complete the main challenge and want to go further:

1. **Add VPC Flow Logs:**
   - Modify your module to optionally enable VPC Flow Logs
   - Send logs to CloudWatch Logs
   - Add variable to control log retention period

2. **Create Multiple Module Versions:**
   - Add a feature (e.g., VPC endpoints for S3)
   - Release as version 1.1.0
   - Update parent config to use new version

3. **Add VPC Peering:**
   - Create a second VPC using your module
   - Establish VPC peering connection
   - Test connectivity between VPCs

4. **Implement Auto Scaling:**
   - In your parent config, replace single private instance with Auto Scaling Group
   - Add Application Load Balancer
   - Test high availability

5. **CI/CD Pipeline:**
   - Set up GitHub Actions to run tests automatically on pull requests
   - Auto-publish new module versions on tag creation

6. **Cost Optimization Test:**
   - Create a test comparing costs of single NAT gateway vs. multi-NAT gateway
   - Use Terraform's built-in testing with different configurations

---

## Common Pitfalls to Avoid

1. **CIDR Block Conflicts:** Ensure your subnet CIDRs don't overlap and fit within the VPC CIDR
2. **AZ Availability:** Some regions have more AZs than others; use data sources to discover available AZs
3. **NAT Gateway Costs:** NAT gateways incur hourly charges; remember to destroy resources when testing
4. **Key Pair Location:** Ensure your SSH key is in the correct format and location
5. **Security Group Rules:** Double-check CIDR blocks in security group rules match your VPC configuration
6. **Route Table Associations:** Verify each subnet is associated with the correct route table
7. **Module Versioning:** Don't forget to tag your repository before publishing to HCP

---

## Time Allocation Guidance

- **Part 1 (Module Creation):** 30 minutes
- **Part 2 (Testing):** 20 minutes
- **Part 3 (Publishing):** 10 minutes
- **Part 4 (Parent Config):** 30 minutes
- **Part 5 (Validation):** 15 minutes

**Total Estimated Time:** 105 minutes (1 hour 45 minutes)

Take breaks as needed. This is a comprehensive challenge that tests your understanding of:
- Terraform module development
- Testing strategies
- HCP Terraform workflows
- AWS networking concepts
- Security best practices
- Infrastructure validation

---

## Resources

You may reference:
- Previous lab materials
- Terraform AWS Provider Documentation
- HCP Terraform Documentation
- AWS VPC Documentation
- Your previous lab code and notes

**Good luck! This challenge will demonstrate your ability to build production-ready, tested, and reusable infrastructure code.**
