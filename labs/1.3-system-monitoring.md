# System Monitoring

In this lab, you’ll learn how to observe and manage a Linux system under load. You’ll simulate CPU stress and use monitoring tools like top, ps, and vmstat to track system performance. You’ll also explore commands for checking disk usage, memory consumption, and network activity, as well as managing processes and background jobs. By the end, you’ll understand how to interpret system metrics, identify performance issues, and maintain system stability in real-world conditions.

These skills are essential for system administrators, who must continuously monitor resource usage, identify performance bottlenecks, and ensure critical services remain responsive and reliable under varying workloads.


## Stress

Stress is a tool for simulating workloads on a server. We can use it to create processes that use high levels of CPU/Memory.

1. Install a tool named stress. 
```
sudo dnf install stress -y
```

2. Run a stress test that simulates 4 high CPU processes. A process is a running instance of a program.
```
stress -c4 & # 4 workers on CPU
```

3. Examine the top processes of your system. Use "h" key to open the help menu and try out some of the other options.
```
top
```
> “Which processes are consuming the most CPU? How can you confirm that the stress tool is responsible?”

4. Use the `ps` command to look at your processes. Notice man page for the `ps` command has many options. Notice the columns that display context about the process change with different options. 
```
ps aux # BSD syntax
ps -ef # standard syntax
ps -efH # H is for hierarchy, will display a process tree
ps -eo pid,ppid,cmd,%mem,%cpu # o allows you to specify the output parameters
ps -eo pid,%cpu,cmd --sort=%cpu # sorts on CPU
```

4. Kill the 4 processes associated to the stress test. You can find the PIDs and kill them individually.
```
kill $PID_TO_KILL # replace $PID_TO_KILL with your pid
# kill all "stress" processes
```

5. Did the processes terminate successfully? Maybe, but we could use kill -9 as a force kill. If the processes are still running, use kill -9.
```
ps -ef | grep [s]tress # check if any stress processes still remain
kill -9 $PID
```

6. The `kill` command doesn’t just terminate processes — it sends signals that can pause, resume, or gracefully stop them.
```
kill -l
```
Some of the most commonly used include:
- SIGTERM (15): Politely asks a process to terminate (default signal for kill).
- SIGKILL (9): Forcefully kills a process immediately; cannot be caught or ignored.
- SIGINT (2): Interrupts a process (like pressing Ctrl+C).
- SIGHUP (1): Sent when a terminal is closed; often used to reload configuration files.
- SIGSTOP (19): Pauses a process (cannot be caught).
- SIGCONT (18): Resumes a stopped process.

7. Create the stress test again and this time use pgrep, pidof and pkill to find all PIDs with stress, and kill all PIDS from stress. Be cautious when using pkill, as you may kill unintended processes.
```
stress -c 4 &
pidof stress # find all pids from stress
pgrep stress # find all pids matching stress in CMD
pkill -9 stress # kill all pids with stress. Can be dangerous! 
```

## System Information and Monitoring

1. The `uname` command prints system information. We can print all details of uname with -a. Explore some of the other options from the manual.
```
uname -a
man uname
uname -r # prints kernel version, useful for compatibility checks
```

2. We can get information from our processor in the /proc folder. Same for memory
```
cat /proc/cpuinfo | head -10   # view processor details
cat /proc/meminfo | head -5    # view memory stats
df -h                          # view disk usage
free -h                        # memory usage snapshot
vmstat                         # similar to free
uptime                         # show load averages
```

3. Sometimes, we need to know `who` is logged into the server, and what they are up to. 
```
who      # shows who is logged in
w        # shows who is logged in and what they are doing
last     # shows recent login history
uptime   # shows how long the system has been running
```

4. The `df` command displays all mounted filesystems along with their total size, used space, and available free space.
Compare this to the `mount` command, which lists every mounted filesystem — including virtual and temporary ones — along with their mount options. 
```
df -h # -h is for human readable
df -i # shows how many inodes are available
mount
# lsblk # The lsblk command lists all block devices on your system
```

> “Which filesystem appears to be using the most space, and what might you check next if it’s nearly full?”

5. The dmesg command displays messages from the kernel ring buffer — logs about hardware, drivers, and system startup.
It’s useful for diagnosing boot issues or when new hardware (like USB drives) is connected.
The output can be long, so you can filter or view only recent messages:
```
sudo dmesf | tail
```

## Conclusion

In this lab, you practiced using essential Linux commands to monitor, analyze, and manage system performance. You learned how to identify resource usage, inspect running processes, and control them using tools like top, ps, and kill. You also explored how to retrieve system and hardware details, view logs, and check file system usage to understand the overall health of a system.
These skills form the foundation of system administration and troubleshooting. Being able to interpret metrics, recognize abnormal behavior, and act quickly to restore stability is what keeps production systems reliable. As you move forward, try combining these tools in real-time scenarios — such as diagnosing high CPU usage or disk bottlenecks — to strengthen your confidence and intuition as a Linux administrator.


