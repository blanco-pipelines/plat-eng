# Lab 5.0 – System Administration Tool Capstone Project

## Overview

Congratulations on completing the foundational labs! You've built a comprehensive skill set spanning file management, text processing, scripting, user administration, process management, networking, service management, and system configuration.

This capstone project challenges you to integrate everything you've learned into a single, practical system administration tool. You have creative freedom to design a tool that solves real problems system administrators face daily.

### Estimated Time: 4-8 Hours (spread across multiple sessions)

## Learning Objectives

By completing this capstone, you will:
- Integrate skills from all previous labs into one cohesive project
- Design and implement a production-quality command-line tool
- Apply security best practices and error handling throughout
- Document your work clearly for other administrators
- Think critically about real-world system administration challenges

## Requirements

Your tool must demonstrate proficiency in at least 6 of the following areas:

1. **Shell Scripting** - Proper shebang, error handling (`set -e`, `set -u`), functions, and modular code
2. **Argument Parsing** - Accept command-line arguments with validation and helpful usage messages
3. **File Operations** - Create, modify, search, or manage files using tools like `find`, `grep`, `awk`, or `sed`
4. **User/Group Management** - Create users, manage groups, or modify permissions safely
5. **Process Management** - Monitor, control, or limit processes using signals, nice/renice, or systemd-run
6. **Logging** - Maintain detailed logs of operations with timestamps
7. **Configuration Files** - Create, parse, or modify system configuration files
8. **Service Integration** - Work with systemd services or timers
9. **Network Operations** - Check connectivity, test ports, or gather network information
10. **Security** - Implement sudo integration, file permission checks, or audit capabilities
11. **Automation** - Schedule tasks using cron or systemd timers
12. **Error Handling** - Gracefully handle failures with informative messages

## Project Structure Best Practices

Your project should follow professional standards:

```
project-name/
├── README.md              # Documentation, usage examples, installation
├── project-name.sh        # Main script (or just 'project-name' if in $PATH)
├── config.conf            # Configuration file (optional)
├── lib/                   # Helper functions (optional, for complex projects)
│   └── helpers.sh
├── tests/                 # Test scripts (optional)
│   └── test_suite.sh
└── install.sh             # Installation script (optional)
```

## Suggested Project Ideas

### Project 1: `sudoctl` - Safe Sudo Configuration Manager

A tool for safely adding users to sudoers with pre-defined security templates.

**Core Features:**
- Interactive wizard for adding sudo privileges to users
- Pre-defined templates: read-only, service-manager, full-admin, custom
- Validates users exist before modifying sudoers
- Uses `visudo` for safe editing
- Maintains audit log of all sudo changes with timestamps
- Can revoke sudo access and backup previous configurations
- List all users with sudo access and their privilege levels

**Advanced Features:**
- Sudo access expiration (using systemd timers to auto-revoke)
- Notification system for sudo privilege changes
- Integration with user creation workflow
- Security audit mode: scan for overly permissive sudo rules
- Dry-run mode to preview changes before applying

**Example Usage:**
```bash
sudoctl add alice --template service-manager
sudoctl add bob --commands "/usr/bin/systemctl, /usr/bin/journalctl" --nopasswd
sudoctl list
sudoctl revoke alice
sudoctl audit --check-security
```

### Project 2: `trash` - Safe File Deletion with Recovery

A replacement for `rm` that allows file recovery, automatic compression, and scheduled cleanup.

**Core Features:**
- Move files to `~/.trash/` directory instead of permanent deletion
- Preserve original directory structure for accurate restoration
- Compress deleted files automatically to save space
- List all trashed files with deletion timestamps and original locations
- Restore files to their original location
- Empty trash with confirmation prompt
- Automatic cleanup of files older than N days (configurable)

**Advanced Features:**
- Systemd timer for automatic old file cleanup
- Search trashed files by name, date, or size
- Protection against trashing system files
- Trash statistics (total size, file count, oldest file)
- Integration with `find` to trash files matching patterns
- Export/import trash state for backup purposes
- Configurable compression levels (gzip, bzip2, xz)

**Example Usage:**
```bash
trash file.txt                           # Move to trash
trash --list                             # Show all trashed files
trash --restore file.txt                 # Restore to original location
trash --search "*.log"                   # Find trashed log files
trash --empty                            # Empty trash with confirmation
trash --clean-older-than 30              # Remove files older than 30 days
trash --stats                            # Show trash statistics
```

### Project 3: `sandbox` - Process Isolation and Resource Control

A tool that runs executables in isolated environments with resource limits using systemd-run and cgroups.

**Core Features:**
- Run any command in a resource-limited environment
- Set CPU limits (percentage or cores)
- Set memory limits (MB/GB)
- Set execution time limits
- Isolated network option (no network access)
- Capture and display all output
- Report resource usage after execution
- Kill sandbox if resources exceeded

**Advanced Features:**
- Create named sandboxes with saved configurations
- Filesystem isolation (read-only root, temporary writable directories)
- Process limit enforcement
- Automatic cleanup of sandbox processes
- Monitor sandbox in real-time with stats
- Sandbox presets: light, medium, heavy, custom
- Logging all sandbox executions with resource usage
- Integration with system security policies

**Example Usage:**
```bash
sandbox --cpu 50 --memory 512M ./script.sh
sandbox --timeout 30s --no-network python suspicious.py
sandbox --preset light "make build"
sandbox --monitor myapp
sandbox --list                           # Show active sandboxes
sandbox --stats sandbox-123              # Show resource usage
sandbox --create-preset dev-build --cpu 200 --memory 2G
```

## Your Own Project Idea

Feel free to create your own system administration tool! Consider these problem areas:

- **Log analyzer**: Parse and summarize system logs with alerts for errors
- **Backup manager**: Automated backups with rotation and compression
- **Health monitor**: Continuous system health checks with notifications
- **Service guardian**: Monitor critical services and auto-restart on failure
- **User onboarding**: Automated user creation with team-based configurations
- **Config manager**: Version control for system configuration files
- **Network scanner**: Network security audit tool
- **Disk cleaner**: Find and remove large/old files with safety checks
- **Package auditor**: Track package changes and security updates
- **Certificate manager**: Monitor and renew SSL certificates

## Final Tips

- **Start simple**: Get basic functionality working before adding features
- **Test frequently**: Run your script after each feature addition
- **Use version control**: Git helps you track changes and revert mistakes
- **Read error messages**: They tell you exactly what's wrong
- **Ask for help**: Discuss design decisions and get feedback early
- **Document as you go**: Don't leave documentation for the end
- **Think about users**: Make error messages helpful and clear
- **Consider security**: Always validate input and check permissions

## Conclusion

This mini capstone project is your opportunity to demonstrate mastery of Linux system administration fundamentals. You've learned the commands, techniques, and best practices—now it's time to build something useful that real administrators would want to use.

Remember: professional system administrators don't memorize every command or option. They understand concepts, know where to look for documentation, and can piece together solutions by combining tools effectively. This project tests exactly those skills.

**Good luck, and build something you're proud of!**
