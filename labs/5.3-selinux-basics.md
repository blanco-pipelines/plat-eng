# SELinux Basics

Security-Enhanced Linux (SELinux) is a mandatory access control (MAC) security mechanism built into the Linux kernel. Unlike traditional Linux permissions that control what a user can do, SELinux controls what processes and applications can access, providing an additional layer of security.

Understanding SELinux is essential for system administrators working on Red Hat Enterprise Linux (RHEL), CentOS, Fedora, and Amazon Linux distributions. While SELinux can seem complex initially, learning the basics helps you troubleshoot common issues and maintain secure systems without disabling this important security feature.

Even if SELinux is disabled in your current environment, understanding how it works prepares you for production systems where it should be enabled to prevent security breaches and limit damage from compromised applications.

### Estimated Time: 20 Minutes

## Part 1: Understanding SELinux Basics

SELinux implements security policies that define what processes can access which files, ports, and resources. It operates in one of three modes and uses contexts (labels) to control access.

1. Check if SELinux is installed and running
```
# Check SELinux status
sestatus
```

If SELinux is not installed, you can install it (Amazon Linux 2023):
```
# should be installed already
# sudo dnf install -y selinux-policy selinux-policy-targeted
```

2. Check current SELinux mode
```
getenforce
```

**SELinux modes:**
- **Enforcing** - SELinux is active and blocking unauthorized actions
- **Permissive** - SELinux is active but only logging violations (not blocking)
- **Disabled** - SELinux is completely disabled

3. View detailed SELinux status
```
sestatus
```

**Understanding the output:**
- `SELinux status` - Whether SELinux is loaded
- `Current mode` - enforcing, permissive, or disabled
- `Mode from config file` - Mode set in configuration
- `Policy` - Usually "targeted" (protects specific services)
- `Loaded policy name` - Which policy is active

4. View SELinux configuration file
```
less /etc/selinux/config
```

The config file sets the default mode and policy that activate at boot.

## Part 2: SELinux Contexts (Labels)

SELinux uses security contexts (labels) on files, processes, and ports. Contexts follow this format:
```
user:role:type:level
```

For most purposes, the **type** field is what matters—it defines what kind of access is allowed.

1. View SELinux contexts on files
```
# -Z will print security context of a file
ls -Z /etc/passwd
ls -Z /etc/ssh/
```

**Understanding the context:**
```
system_u:object_r:passwd_file_t:s0 /etc/passwd
   └─ user  └─ role └─ type      └─ level
```

- `user` - SELinux user (usually system_u for system files)
- `role` - SELinux role (usually object_r for files)
- `type` - Most important: defines what can access this file
- `level` - Multi-Level Security (MLS) level (usually s0)

2. View SELinux contexts on processes
```
ps -eZ | grep sshd
ps -eZ | grep httpd
```

Processes also have contexts that determine what they can access.

3. View your current user's SELinux context
```
id -Z
```

## Part 3: Common SELinux File Contexts

Different directories and file types have different SELinux contexts. Understanding common contexts helps troubleshoot issues.

1. View contexts for common system directories
```
ls -Zd /var/log
ls -Zd /var/www/html
ls -Zd /etc
ls -Zd /home
```

2. Create a test directory and observe its context
```
mkdir -p ~/selinux_test
touch ~/selinux_test/test_file.txt
ls -Z ~/selinux_test/
```

Notice the context is inherited from the parent directory.

3. View SELinux contexts on the web server directory (if Apache is installed)
```
# Install Apache if not already installed
sudo dnf install -y httpd

# Check default web content context
ls -Zd /var/www/html

# create a file for the webserver to serve
echo "SELinux web test" | sudo tee /var/www/html/test.html

# restart web server and confirm it works
sudo systemctl restart httpd
curl localhost/test.html

# Confirm the security context type is same as parent directory
sudo ls -Z /var/www/html/
```

Files in `/var/www/html` should have the `httpd_sys_content_t` type. This means that processes running with the `httpd_t` context (as seen with `ps -eZ | grep httpd`) are allowed to read and serve these files. SELinux uses these type labels to control which processes can access which files—this is how it prevents compromised services from accessing files they shouldn't.

## Part 4: SELinux Modes - Temporarily Changing

You can temporarily change SELinux mode without rebooting. This is useful for testing if SELinux is blocking something.

1. Check current mode
```
getenforce
```

2. Temporarily set to permissive mode (requires sudo)
```
# note that you may already be in permissive mode
sudo setenforce 0
getenforce
```

In permissive mode, SELinux logs violations but doesn't block them.

3. Set to enforcing mode
```
sudo setenforce 1
getenforce
```

**Important notes:**
- `setenforce` changes only last until reboot
- To permanently change mode, edit `/etc/selinux/config`
- Never disable SELinux in production
- use permissive mode for troubleshooting

4. View the difference between temporary and permanent settings
```
sestatus
```

Notice "Current mode" vs "Mode from config file" may differ.

## Part 5: SELinux Troubleshooting Basics

When SELinux blocks an action, it logs the denial. Learning to read these logs is crucial for troubleshooting.

1. View recent SELinux denials (if any)
```
sudo ausearch -m avc -ts recent 
```

2. View SELinux messages in system logs
```
sudo journalctl -t setroubleshoot --since "1 hour ago" --no-pager 
```

**Common SELinux issues:**
- Web server can't read files (wrong context)
- Service can't bind to non-standard port
- Application can't write to a directory
- Custom scripts fail due to context mismatch

## Part 6: Fixing File Contexts

If a file has the wrong SELinux context, you can restore it or set it manually.

1. Create a test scenario—move a file to the web directory
```
# Create a test file in home directory
echo "Test content from home" > ~/selinux_test/test2.html

# Check its context (will have user_home_t type)
ls -Z ~/selinux_test/test2.html
```

2. Move it to the web directory (this preserves the old context)
```
sudo mv ~/selinux_test/test2.html /var/www/html/ 
```

3. Check the context (it will be wrong - still has user_home_t type)
```
sudo ls -Z /var/www/html/test2.html
```

Notice it still has `user_home_t` instead of `httpd_sys_content_t`. This is why the web server can't read it!

4. Try to access it via the web server (should fail if SELinux is enforcing)
```
curl localhost/test2.html
# May see "403 Forbidden" or connection error
```

5. Restore the correct context based on policy
```
sudo restorecon -v /var/www/html/test2.html
sudo ls -Z /var/www/html/test2.html
```

Now it should have `httpd_sys_content_t` type.

**`restorecon` explained:**
- Restores default SELinux contexts based on the policy for that directory
- The file inherits the correct context from the parent directory's policy rules
- For `/var/www/html/`, the policy says files should have `httpd_sys_content_t` type
- `-v` - Verbose (shows what changed)
- `-R` - Recursive (for directories)

6. Try to access it again (should work now)
```
curl localhost/test2.html
```

7. Manually set a specific context (alternative method)
```
# First, let's break it again for demonstration
sudo chcon -t user_home_t /var/www/html/test2.html

# Verify it's wrong
sudo ls -Z /var/www/html/test2.html

# Now fix it manually
sudo chcon -t httpd_sys_content_t /var/www/html/test2.html
sudo ls -Z /var/www/html/test2.html
```

**`chcon` vs `restorecon`:**
- `chcon` - Manually set context (temporary, may be overwritten)
- `restorecon` - Restore policy-based context (preferred method)
- Use `restorecon` in production for persistent changes

8. Check the audit logs for SELinux denials
```
# View recent SELinux denials (AVC denials)
sudo ausearch -m avc -ts recent

# You should see denials from when httpd tried to access the file with wrong context
# Look for lines with "denied" and "comm="httpd""
```

9. Check journalctl for SELinux messages
```
# View SELinux-related messages
sudo journalctl -t setroubleshoot --since "10 minutes ago" --no-pager

# Note: journalctl may be empty if setroubleshoot isn't running
# The audit log (ausearch) is the primary source for SELinux denials
```

**Understanding the logs:**
- When SELinux blocks access, it logs an AVC (Access Vector Cache) denial
- The audit log shows what was denied, which process, and what file/resource
- These logs are essential for troubleshooting SELinux issues in production

## Part 7: SELinux Booleans

SELinux booleans are switches that enable or disable specific policy features without rewriting the entire policy.

1. List all SELinux booleans
```
getsebool -a | head -20
```

2. Search for specific booleans (example: HTTP-related)
```
getsebool -a | grep httpd
```

3. Temporarily enable a boolean (example only)
```
# Allow httpd to make network connections (if needed)
# sudo setsebool httpd_can_network_connect on

# Make it persistent across reboots
# sudo setsebool -P httpd_can_network_connect on
```

**Common booleans:**
- `httpd_can_network_connect` - Allow web server to make outbound connections
- `httpd_enable_homedirs` - Allow serving content from user home directories
- `ftpd_full_access` - Allow FTP full access to filesystem
- `samba_enable_home_dirs` - Allow Samba to share home directories

## Part 8: Real-World SELinux Scenarios

Understanding common scenarios helps you recognize and fix SELinux issues quickly.

1. **Scenario 1: Web server can't read files**
```
# Problem: Files copied from home directory can't be served by Apache
# Solution: Restore correct context
# sudo restorecon -Rv /var/www/html/
```

2. **Scenario 2: Application can't write to a directory**
```
# Problem: App needs to write to /opt/app/data but SELinux blocks it
# Solution: Set appropriate writable context
# sudo semanage fcontext -a -t httpd_sys_rw_content_t "/opt/app/data(/.*)?"
# sudo restorecon -Rv /opt/app/data
```

3. **Scenario 3: Service won't bind to non-standard port**
```
# Problem: SSH won't listen on port 2222
# Solution: Add port to SELinux policy
# sudo semanage port -a -t ssh_port_t -p tcp 2222
```

4. **Scenario 4: Check if SELinux is blocking something**
```
# Temporarily set to permissive and test
# If problem goes away, SELinux was the issue
# Check logs with: sudo sealert -a /var/log/audit/audit.log
```

## Part 9: Best Practices

1. **Never disable SELinux in production**
   - If troubleshooting, use permissive mode temporarily
   - Fix the root cause instead of disabling security

2. **Use restorecon, not chcon**
   - `restorecon` applies policy-based contexts
   - Changes persist through relabeling
   - `chcon` changes may be lost

3. **Check logs when troubleshooting**
   - SELinux denials are logged in audit log
   - Use `sealert` for helpful suggestions
   - Look for AVC (Access Vector Cache) denials

4. **Understand before changing**
   - Don't randomly try fixes from the internet
   - Understand what each command does
   - Document changes for future reference

5. **Use booleans when possible**
   - Safer than custom policy modules
   - Easier to understand and maintain
   - Well-documented and tested

## Cleanup
```
cd ~
rm -rf ~/selinux_test
# put back in permissive mode
sudo setenforce 0
getenforce
```

## Conclusion

In this lab, you learned the fundamentals of SELinux for Linux system administration:

- **SELinux modes**: Understanding enforcing, permissive, and disabled modes and how to check/change them
- **Security contexts**: Reading and interpreting file and process labels (user:role:type:level)
- **File contexts**: Using `ls -Z` to view contexts and understanding common types
- **Troubleshooting**: Using `restorecon` to fix context issues and `ausearch`/`sealert` to view denials
- **SELinux booleans**: Enabling/disabling policy features safely with `getsebool` and `setsebool`
- **Best practices**: Never disabling SELinux, using proper tools, and checking logs

SELinux provides critical security by limiting what processes can do, even if they're compromised. While it can seem intimidating at first, understanding these basics enables you to:

- Troubleshoot common SELinux denials quickly
- Maintain secure systems without disabling SELinux
- Fix context issues on web servers and applications
- Recognize when SELinux is protecting your system from attacks

**Key takeaways:**
- SELinux is a security feature, not a problem to disable
- Most issues are fixed with `restorecon` or SELinux booleans
- Check logs (`ausearch`, `sealert`) before making changes
- Use permissive mode for testing, not as a permanent solution
- Document SELinux changes for future troubleshooting

As you progress in system administration, you'll encounter SELinux regularly on RHEL-based systems. These fundamentals provide the foundation for managing secure Linux environments and troubleshooting access issues without compromising security.
