# SELinux Basics

Security-Enhanced Linux (SELinux) is a mandatory access control (MAC) security mechanism built into the Linux kernel. Unlike traditional Linux permissions that control what a user can do, SELinux controls what processes and applications can access, providing an additional layer of security.

Understanding SELinux is essential for system administrators working on Red Hat Enterprise Linux (RHEL), CentOS, Fedora, and Amazon Linux distributions. While SELinux can seem complex initially, learning the basics helps you troubleshoot common issues and maintain secure systems without disabling this important security feature.

Even if SELinux is disabled in your current environment, understanding how it works prepares you for production systems where it should be enabled to prevent security breaches and limit damage from compromised applications.

### Estimated Time: 20 Minutes

## Part 1: Understanding SELinux Basics

SELinux implements security policies that define what processes can access which files, ports, and resources. It operates in one of three modes and uses contexts (labels) to control access.

1. Check if SELinux is installed and running
```
# Check SELinux status
sestatus
```

If SELinux is not installed, you can install it (Amazon Linux 2023):
```
sudo dnf install -y selinux-policy selinux-policy-targeted
```

2. Check current SELinux mode
```
getenforce
```

**SELinux modes:**
- **Enforcing** - SELinux is active and blocking unauthorized actions
- **Permissive** - SELinux is active but only logging violations (not blocking)
- **Disabled** - SELinux is completely disabled

3. View detailed SELinux status
```
sestatus
```

**Understanding the output:**
- `SELinux status` - Whether SELinux is loaded
- `Current mode` - enforcing, permissive, or disabled
- `Mode from config file` - Mode set in configuration
- `Policy` - Usually "targeted" (protects specific services)
- `Loaded policy name` - Which policy is active

4. View SELinux configuration file
```
cat /etc/selinux/config
```

The config file sets the default mode and policy that activate at boot.

## Part 2: SELinux Contexts (Labels)

SELinux uses security contexts (labels) on files, processes, and ports. Contexts follow this format:
```
user:role:type:level
```

For most purposes, the **type** field is what matters—it defines what kind of access is allowed.

1. View SELinux contexts on files
```
ls -Z /etc/passwd
ls -Z /var/www/html/
ls -Z /etc/ssh/
```

**Understanding the context:**
```
system_u:object_r:passwd_file_t:s0 /etc/passwd
         └─ user  └─ role └─ type └─ level
```

- `user` - SELinux user (usually system_u for system files)
- `role` - SELinux role (usually object_r for files)
- `type` - Most important: defines what can access this file
- `level` - Multi-Level Security (MLS) level (usually s0)

2. View SELinux contexts on processes
```
ps -eZ | grep sshd
ps -eZ | grep httpd
```

Processes also have contexts that determine what they can access.

3. View your current user's SELinux context
```
id -Z
```

## Part 3: Common SELinux File Contexts

Different directories and file types have different SELinux contexts. Understanding common contexts helps troubleshoot issues.

1. View contexts for common system directories
```
ls -Zd /var/log
ls -Zd /var/www/html
ls -Zd /etc
ls -Zd /home
```

2. Create a test directory and observe its context
```
mkdir -p ~/selinux_test
touch ~/selinux_test/test_file.txt
ls -Z ~/selinux_test/
```

Notice the context is inherited from the parent directory.

3. View SELinux contexts on the web server directory (if Apache is installed)
```
# Install Apache if not already installed
sudo dnf install -y httpd

# Check default web content context
ls -Zd /var/www/html
sudo ls -Z /var/www/html/ 2>/dev/null || echo "Directory empty"
```

Files in `/var/www/html` should have the `httpd_sys_content_t` type.

## Part 4: SELinux Modes - Temporarily Changing

You can temporarily change SELinux mode without rebooting. This is useful for testing if SELinux is blocking something.

1. Check current mode
```
getenforce
```

2. Temporarily set to permissive mode (requires sudo)
```
sudo setenforce 0
getenforce
```

In permissive mode, SELinux logs violations but doesn't block them.

3. Set back to enforcing mode
```
sudo setenforce 1
getenforce
```

**Important notes:**
- `setenforce` changes only last until reboot
- To permanently change mode, edit `/etc/selinux/config`
- Never disable SELinux in production—use permissive mode for troubleshooting

4. View the difference between temporary and permanent settings
```
sestatus
```

Notice "Current mode" vs "Mode from config file" may differ.

## Part 5: SELinux Troubleshooting Basics

When SELinux blocks an action, it logs the denial. Learning to read these logs is crucial for troubleshooting.

1. View recent SELinux denials (if any)
```
sudo ausearch -m avc -ts recent 2>/dev/null || echo "No recent denials found"
```

2. View SELinux messages in system logs
```
sudo journalctl -t setroubleshoot --since "1 hour ago" --no-pager 2>/dev/null || echo "No setroubleshoot messages"
```

3. Install SELinux troubleshooting tools
```
sudo dnf install -y setroubleshoot-server setools-console
```

4. Generate helpful suggestions for SELinux issues
```
sudo sealert -a /var/log/audit/audit.log 2>/dev/null | tail -20
```

**Common SELinux issues:**
- Web server can't read files (wrong context)
- Service can't bind to non-standard port
- Application can't write to a directory
- Custom scripts fail due to context mismatch

## Part 6: Fixing File Contexts

If a file has the wrong SELinux context, you can restore it or set it manually.

1. Create a test scenario—copy a file to the web directory
```
# Create a test file in home directory
echo "Test content" > ~/selinux_test/test.html

# Check its context
ls -Z ~/selinux_test/test.html
```

2. Copy it to the web directory (if Apache is installed)
```
sudo cp ~/selinux_test/test.html /var/www/html/ 2>/dev/null || mkdir -p ~/selinux_test/www_test && sudo cp ~/selinux_test/test.html ~/selinux_test/www_test/
```

3. Check the context (it may be wrong after copying)
```
ls -Z ~/selinux_test/www_test/test.html
```

4. Restore the correct context based on policy
```
sudo restorecon -v ~/selinux_test/www_test/test.html
ls -Z ~/selinux_test/www_test/test.html
```

**`restorecon` explained:**
- Restores default SELinux contexts based on policy
- `-v` - Verbose (show what changed)
- `-R` - Recursive (for directories)

5. Manually set a specific context (alternative method)
```
sudo chcon -t httpd_sys_content_t ~/selinux_test/www_test/test.html
ls -Z ~/selinux_test/www_test/test.html
```

**`chcon` vs `restorecon`:**
- `chcon` - Manually set context (temporary, may be overwritten)
- `restorecon` - Restore policy-based context (preferred method)
- Use `restorecon` in production for persistent changes

## Part 7: SELinux Booleans

SELinux booleans are switches that enable or disable specific policy features without rewriting the entire policy.

1. List all SELinux booleans
```
getsebool -a | head -20
```

2. Search for specific booleans (example: HTTP-related)
```
getsebool -a | grep httpd
```

3. Check a specific boolean value
```
getsebool httpd_can_network_connect 2>/dev/null || echo "Boolean not available"
```

4. View boolean description
```
semanage boolean -l | grep httpd_can_network_connect 2>/dev/null || echo "semanage not available"
```

5. Temporarily enable a boolean (example only)
```
# Allow httpd to make network connections (if needed)
# sudo setsebool httpd_can_network_connect on

# Make it persistent across reboots
# sudo setsebool -P httpd_can_network_connect on
```

**Common booleans:**
- `httpd_can_network_connect` - Allow web server to make outbound connections
- `httpd_enable_homedirs` - Allow serving content from user home directories
- `ftpd_full_access` - Allow FTP full access to filesystem
- `samba_enable_home_dirs` - Allow Samba to share home directories

## Part 8: Real-World SELinux Scenarios

Understanding common scenarios helps you recognize and fix SELinux issues quickly.

1. **Scenario 1: Web server can't read files**
```
# Problem: Files copied from home directory can't be served by Apache
# Solution: Restore correct context
# sudo restorecon -Rv /var/www/html/
```

2. **Scenario 2: Application can't write to a directory**
```
# Problem: App needs to write to /opt/app/data but SELinux blocks it
# Solution: Set appropriate writable context
# sudo semanage fcontext -a -t httpd_sys_rw_content_t "/opt/app/data(/.*)?"
# sudo restorecon -Rv /opt/app/data
```

3. **Scenario 3: Service won't bind to non-standard port**
```
# Problem: SSH won't listen on port 2222
# Solution: Add port to SELinux policy
# sudo semanage port -a -t ssh_port_t -p tcp 2222
```

4. **Scenario 4: Check if SELinux is blocking something**
```
# Temporarily set to permissive and test
# If problem goes away, SELinux was the issue
# Check logs with: sudo sealert -a /var/log/audit/audit.log
```

## Part 9: Best Practices

1. **Never disable SELinux in production**
   - If troubleshooting, use permissive mode temporarily
   - Fix the root cause instead of disabling security

2. **Use restorecon, not chcon**
   - `restorecon` applies policy-based contexts
   - Changes persist through relabeling
   - `chcon` changes may be lost

3. **Check logs when troubleshooting**
   - SELinux denials are logged in audit log
   - Use `sealert` for helpful suggestions
   - Look for AVC (Access Vector Cache) denials

4. **Understand before changing**
   - Don't randomly try fixes from the internet
   - Understand what each command does
   - Document changes for future reference

5. **Use booleans when possible**
   - Safer than custom policy modules
   - Easier to understand and maintain
   - Well-documented and tested

## Cleanup
```
cd ~
rm -rf ~/selinux_test
```

## Conclusion

In this lab, you learned the fundamentals of SELinux for Linux system administration:

- **SELinux modes**: Understanding enforcing, permissive, and disabled modes and how to check/change them
- **Security contexts**: Reading and interpreting file and process labels (user:role:type:level)
- **File contexts**: Using `ls -Z` to view contexts and understanding common types
- **Troubleshooting**: Using `restorecon` to fix context issues and `ausearch`/`sealert` to view denials
- **SELinux booleans**: Enabling/disabling policy features safely with `getsebool` and `setsebool`
- **Best practices**: Never disabling SELinux, using proper tools, and checking logs

SELinux provides critical security by limiting what processes can do, even if they're compromised. While it can seem intimidating at first, understanding these basics enables you to:

- Troubleshoot common SELinux denials quickly
- Maintain secure systems without disabling SELinux
- Fix context issues on web servers and applications
- Recognize when SELinux is protecting your system from attacks

**Key takeaways:**
- SELinux is a security feature, not a problem to disable
- Most issues are fixed with `restorecon` or SELinux booleans
- Check logs (`ausearch`, `sealert`) before making changes
- Use permissive mode for testing, not as a permanent solution
- Document SELinux changes for future troubleshooting

As you progress in system administration, you'll encounter SELinux regularly on RHEL-based systems. These fundamentals provide the foundation for managing secure Linux environments and troubleshooting access issues without compromising security.
