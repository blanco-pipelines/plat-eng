# Operators

Operators allow us to control how commands interact, chain together, and handle input/output in the Linux shell.
They’re the glue that lets you build more powerful one-liners and automation scripts.

```
&& — AND operator: runs the next command only if the previous one succeeds.  
|| — OR operator: runs the next command only if the previous one fails.
; — Command separator: runs multiple commands in sequence, even if one fails.  

| — Pipe operator: sends the output of one command as the input of another (don’t confuse this with ||).

> — Redirect (overwrite): erases a file and writes the command’s output to it.  
>> — Append redirect: adds the output to the end of a file without erasing it.

< — Input redirect: reads input to a command from a file instead of from the keyboard.  
<< EOF ... EOF — Here-Doc: lets you provide a block of text as input to a command.  
<<< — Here-String: redirects a single string as input to a command.

```

## Ternary Operators

1. Every Linux command returns an exit status code when it finishes. 0 means success. Any non-zero value means failure. You can check the exit code of the previous command using the special variable $?.
For example:

```
echo "hello world"
echo $?             # prints 0, indicating the previous command passed
ech "hello world"
echo $?             # prints 1, indicating the previous command failed
```

2. Ternary operators use the `$?` to determine which path to take. Run the commands below, try and consider why each one prints Success or Fail.

```
curl not_a_valid_domain && echo "Success" || echo "Fail" 

curl ifconfig.me && echo "Success" || echo "Fail"

curl ifconfig.me && ech "Success" || echo "Fail" # why do we see Fail here?
```

## Piping

1. Piping takes the output of a command, and redirects it as input to another command. Consider the `grep` command, which prints any line that matches a pattern. It is common practice to use `grep` with pipes. Lets combine piping with some commands we already know.
```
history | grep cd
ps -ef | grep system
ls -la | grep txt # similar as ls -la *.txt
ls --help | grep time -i
ls -ltr | tail -1 # -ltr shows reverse order sorted by time. The pipe to tail -1 prints only the last line.

history | grep cd | tail -1 # combining pipes
```

## Redirecting

When a command is executed, it typically outputs to the terminal, which is a file known as Standard Output. Standard Output is always File Descriptor 1.

1. Redirect the output of a command to a file
```
ps aux > processes.data # file extensions mean nothing in Linux!
history > history.txt
echo "erase" 1> history.txt 
```

> "Notice the 1>, the 1 indicates that we are redirecting the standard output to a file. By default, the 1 is already implied"

2. Redirecting Error Messages
```

```
