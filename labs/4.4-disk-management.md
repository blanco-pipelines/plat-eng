# Disk Management and Filesystems

Disk management is a fundamental responsibility for Linux system administrators. Understanding how to view disk information, create partitions, format filesystems, and mount storage devices enables you to expand storage capacity, organize data, and troubleshoot disk-related issues.

Every file in Linux exists on a filesystem mounted to a directory. Whether you're adding a new disk, mounting external storage, or configuring persistent mounts at boot time, these skills are essential for maintaining storage infrastructure in development and production environments.

The `/etc/fstab` file controls which filesystems mount automatically at boot, making it critical for system stability. A misconfigured fstab can prevent your system from booting, so understanding its syntax and testing changes carefully is crucial.

### Estimated Time: 35 Minutes

## Part 1: Viewing Disk and Filesystem Information

1. Create a working directory for this lab
```
mkdir -p ~/disk_lab && cd ~/disk_lab
```

2. List all block devices (disks and partitions)
```
lsblk
```

**Understanding the output:**
- `NAME` - Device name (sda, nvme0n1, etc.)
- `MAJ:MIN` - Major and minor device numbers
- `RM` - Removable device (1 = yes, 0 = no)
- `SIZE` - Device or partition size
- `TYPE` - Device type (disk, part, lvm, etc.)
- `MOUNTPOINT` - Where the filesystem is mounted

3. Show detailed block device information
```
lsblk -f
```

This adds filesystem type, UUID, and usage information.

4. View partition table information
```
sudo fdisk -l
```

5. Display disk usage for mounted filesystems
```
df -h
```

**Flags explained:**
- `-h` - Human-readable sizes (GB, MB instead of bytes)

6. Show disk usage including filesystem type and inodes
```
df -hT
df -i  # inode usage (important for many small files)
```

7. Display detailed disk information with blkid
```
sudo blkid
```

This shows UUIDs, filesystem types, and partition types—useful for fstab configuration.

## Part 2: Understanding Mount Points

Mount points are directories where filesystems are attached to the directory tree. Everything in Linux is accessed through the unified directory structure starting at `/`.

1. View all currently mounted filesystems
```
mount | column -t
```

2. Check what's mounted at specific locations
```
mount | grep "^/"
findmnt /
```

3. Use findmnt for a tree view of mount points
```
findmnt
findmnt -t ext4,xfs  # Show only specific filesystem types
```

4. Create a test directory to use as a mount point
```
mkdir -p ~/disk_lab/mnt_test
```

## Part 3: Creating and Using a Loop Device

Since we likely don't have spare physical disks, we'll use a loop device—a file that acts like a block device. This is perfect for practice and testing.

1. Create a 100MB file to use as a virtual disk
```
dd if=/dev/zero of=~/disk_lab/virtual_disk.img bs=1M count=100
```

**Command explained:**
- `if=/dev/zero` - Input file (source of null bytes)
- `of=virtual_disk.img` - Output file
- `bs=1M` - Block size (1 megabyte)
- `count=100` - Number of blocks (100 MB total)

2. Verify the file was created
```
ls -lh ~/disk_lab/virtual_disk.img
file ~/disk_lab/virtual_disk.img
```

3. Set up the file as a loop device
```
sudo losetup -fP ~/disk_lab/virtual_disk.img
```

**Flags explained:**
- `-f` - Find the first unused loop device
- `-P` - Force kernel to scan partition table

4. Find which loop device was assigned
```
LOOP_DEVICE=$(losetup -j ~/disk_lab/virtual_disk.img | cut -d: -f1)
echo "Loop device: $LOOP_DEVICE"
```

5. Verify the loop device
```
lsblk | grep loop
sudo losetup -l
```

## Part 4: Creating a Filesystem

1. Create an ext4 filesystem on the loop device
```
sudo mkfs.ext4 -L "TestDisk" $LOOP_DEVICE
```

**Flags explained:**
- `-L "TestDisk"` - Set filesystem label

**Common filesystem types:**
- `ext4` - Default for most Linux distributions (reliable, mature)
- `xfs` - High-performance, good for large files (default on RHEL/Amazon Linux)
- `btrfs` - Modern with snapshots and compression features
- `vfat` - Compatible with Windows (FAT32)

2. Verify the filesystem was created
```
sudo blkid $LOOP_DEVICE
lsblk -f | grep loop
```

Notice the filesystem type (ext4) and UUID.

## Part 5: Mounting and Unmounting Filesystems

1. Mount the filesystem to your test directory
```
sudo mount $LOOP_DEVICE ~/disk_lab/mnt_test
```

2. Verify it's mounted
```
mount | grep mnt_test
df -h | grep mnt_test
lsblk | grep loop
```

3. Create some test files on the mounted filesystem
```
sudo touch ~/disk_lab/mnt_test/test_file.txt
echo "Hello from mounted filesystem" | sudo tee ~/disk_lab/mnt_test/test_file.txt
ls -la ~/disk_lab/mnt_test/
```

4. Check disk usage on the mounted filesystem
```
df -h ~/disk_lab/mnt_test/
```

5. Unmount the filesystem
```
sudo umount ~/disk_lab/mnt_test
```

6. Verify it's unmounted
```
mount | grep mnt_test
ls ~/disk_lab/mnt_test/  # Should be empty now
```

7. Remount and verify the data persisted
```
sudo mount $LOOP_DEVICE ~/disk_lab/mnt_test
cat ~/disk_lab/mnt_test/test_file.txt
```

## Part 6: Understanding /etc/fstab

The `/etc/fstab` file defines filesystems that should mount automatically at boot. Each line specifies a filesystem to mount.

1. View the current fstab configuration
```
cat /etc/fstab
```

2. Understand the fstab format:
```
# <device>  <mount point>  <type>  <options>  <dump>  <pass>
UUID=xxx    /              ext4    defaults   0       1
UUID=yyy    /boot          xfs     defaults   0       2
/dev/sdb1   /data          ext4    defaults   0       2
```

**Field explanations:**
- **Device**: UUID, device path, or label
- **Mount point**: Directory where filesystem mounts
- **Type**: Filesystem type (ext4, xfs, vfat, etc.)
- **Options**: Mount options (defaults, noatime, ro, etc.)
- **Dump**: Backup utility flag (0 = don't backup, 1 = backup)
- **Pass**: fsck check order at boot (0 = no check, 1 = root, 2 = other)

3. View filesystem UUIDs (used in fstab for reliability)
```
sudo blkid
```

**Why use UUID instead of device names?**
- Device names (/dev/sda1) can change between reboots
- UUIDs are unique and persistent
- More reliable in production environments

## Part 7: Creating an fstab Entry (Practice Only)

**⚠️ WARNING: Never edit /etc/fstab directly in production without a backup and testing plan. A broken fstab can prevent the system from booting.**

1. Get the UUID of your loop device
```
LOOP_UUID=$(sudo blkid $LOOP_DEVICE -s UUID -o value)
echo "UUID: $LOOP_UUID"
```

2. Create a sample fstab entry (DO NOT add to actual /etc/fstab)
```
cat << EOF > ~/disk_lab/fstab_entry.txt
# Sample fstab entry for loop device (EXAMPLE ONLY)
UUID=$LOOP_UUID  $HOME/disk_lab/mnt_test  ext4  defaults  0  2
EOF

cat ~/disk_lab/fstab_entry.txt
```

3. Understand common mount options:
```
defaults     - Use default options (rw, suid, dev, exec, auto, nouser, async)
noatime      - Don't update access times (performance improvement)
ro           - Read-only
rw           - Read-write
noexec       - Don't allow execution of binaries
nosuid       - Don't allow setuid/setgid bits
auto         - Mount at boot (default)
noauto       - Don't mount at boot (mount manually)
user         - Allow regular users to mount
```

4. Test mounting using fstab entry format (without editing fstab)
```
# First unmount if mounted
sudo umount ~/disk_lab/mnt_test 2>/dev/null || true

# Mount using UUID (similar to how fstab works)
sudo mount UUID=$LOOP_UUID ~/disk_lab/mnt_test

# Verify
mount | grep mnt_test
```

## Part 8: Safe fstab Testing

If you were to add an entry to fstab in production, you would test it first.

1. Test mounting all fstab entries without rebooting
```
# This command is safe—it only tries to mount what's in fstab
# sudo mount -a
```

2. If you had added an fstab entry, you would:
```
# 1. Unmount the filesystem
# sudo umount /mount/point

# 2. Test the fstab entry
# sudo mount -a

# 3. Verify it mounted correctly
# mount | grep /mount/point

# 4. If it works, reboot to confirm it survives reboot
# sudo reboot
```

**Best practices:**
- Always keep a backup of fstab before editing: `sudo cp /etc/fstab /etc/fstab.backup`
- Test with `mount -a` before rebooting
- Use UUIDs instead of device names
- Have console access before rebooting (important for cloud/remote systems)

## Part 9: Disk Usage Analysis

1. Check overall disk usage
```
df -h
```

2. Find large directories
```
sudo du -h --max-depth=1 /var | sort -hr | head -10
sudo du -h --max-depth=1 /home | sort -hr | head -10
```

3. Find the largest files in your home directory
```
find ~ -type f -exec du -h {} + 2>/dev/null | sort -hr | head -20
```

4. Check inode usage (important when storing many small files)
```
df -i
```

**Understanding inodes:**
- Each file uses one inode (metadata structure)
- You can run out of inodes even with free disk space
- Common with millions of small files (logs, cache)

## Cleanup

1. Unmount the loop device
```
sudo umount ~/disk_lab/mnt_test 2>/dev/null || true
```

2. Detach the loop device
```
sudo losetup -d $LOOP_DEVICE
```

3. Verify cleanup
```
losetup -l | grep virtual_disk
mount | grep mnt_test
```

4. Remove test files
```
cd ~
rm -rf ~/disk_lab
```

## Conclusion

In this lab, you mastered essential disk management skills for Linux system administration:

- **Disk inspection**: Using `lsblk`, `fdisk`, `df`, and `blkid` to view disk and partition information
- **Block devices**: Understanding how physical and virtual disks appear in Linux
- **Filesystems**: Creating filesystems with `mkfs` and understanding ext4, xfs, and other types
- **Mounting**: Manually mounting and unmounting filesystems with `mount` and `umount`
- **fstab configuration**: Understanding `/etc/fstab` structure, UUIDs, mount options, and best practices
- **Loop devices**: Using file-backed loop devices for testing and development
- **Disk usage analysis**: Finding large files and directories with `du` and monitoring inode usage

These skills are critical for:
- Adding new storage to systems
- Managing cloud volumes (EBS, persistent disks)
- Configuring database and application storage
- Troubleshooting "disk full" issues
- Setting up NFS, CIFS, or other network filesystems
- Creating consistent, reliable boot configurations

Understanding disk management enables you to maintain storage infrastructure confidently, whether you're working with physical servers, virtual machines, or cloud instances. The concepts you've learned here apply across all modern Linux distributions and cloud platforms.

**⚠️ Important Reminders:**
- Always backup `/etc/fstab` before editing
- Test fstab changes with `mount -a` before rebooting
- Use UUIDs for reliability in production
- Never force unmount busy filesystems without understanding the consequences
- Keep console access when testing storage configurations on remote systems
