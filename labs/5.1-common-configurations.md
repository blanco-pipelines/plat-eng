# Common Configuration Files

Understanding key system configuration files is essential for Linux system administrators. These files control critical aspects of system behavior—from user privileges and log management to SSH access and shell environments.

Configuration files in `/etc` define how the system operates, and many support modular configurations through `.d` directories. This modular approach allows you to add custom configurations without modifying the main file, making system management cleaner and reducing the risk of errors during updates.

Mastering these common configurations enables you to grant controlled sudo access, manage log file rotation to prevent disk space issues, secure SSH connections, and customize user environments efficiently.

### Estimated Time: 30 Minutes

## Part 1: Understanding sudoers

The sudoers file controls which users can execute commands with elevated privileges. Editing this file improperly can lock you out of administrative access, which is why we always use `visudo` to edit it safely.

1. View the main sudoers file (read-only)
```
sudo less /etc/sudoers
```

2. Understand the sudoers syntax. The basic format is:
```
user    host=(runas_user:runas_group)    commands
```

Common examples:
```
# Allow root to run any command anywhere
root    ALL=(ALL:ALL) ALL

# Allow members of wheel group to run all commands
%wheel  ALL=(ALL:ALL) ALL
```

3. Create sample sudoers entries to understand the syntax
```
# Allow alice to run systemctl status and view logs (read-only commands)
alice ALL=(ALL) NOPASSWD: /usr/bin/systemctl status *, /usr/bin/journalctl

# Allow user to run commands as specific user
bob     ALL=(apache) /usr/bin/vim /var/www/html/*
```

**Syntax breakdown:**
- `user` or `%group` - Who the rule applies to (% prefix for groups)
- `ALL` (first) - Which hosts this rule applies to
- `(ALL:ALL)` - Which users:groups commands can be run as
- `ALL` (last) - Which commands are allowed (or specific paths)
- `NOPASSWD:` - Skip password prompt for these commands

4. Check which sudo privileges your current user has
```
sudo -l
```

## Part 2: Using sudoers.d Directory

Rather than editing the main sudoers file, best practice is to create separate files in `/etc/sudoers.d/`. This keeps custom configurations organized and prevents conflicts during system updates.

1. Check if sudoers.d directory exists and is included
```
ls -la /etc/sudoers.d/
sudo grep "sudoers.d" /etc/sudoers
```

2. Create a new user named alice for testing
```
sudo useradd alice
sudo passwd alice
# Enter a password you'll remember (e.g., "password123")
```

3. Try to switch to alice and test sudo access
```
sudo su - alice
# Now you're logged in as alice

# Try to use sudo
sudo ls /root
# You should see "alice is not in the sudoers file"

# Exit back to your original user
exit
```

4. Grant alice sudo access using sudoers.d
```
# Use visudo to create a new sudoers.d file
sudo visudo -f /etc/sudoers.d/alice
```

> Always use visudo when making sudo changes.

5. In the editor, add the following content (then save and exit):
```
# Allow alice to run systemctl status and view logs (read-only commands)
alice ALL=(ALL) NOPASSWD: /usr/bin/systemctl status *, /usr/bin/cat /var/log/*
```

5a. Validate the sudoers file syntax
```
# Check syntax of the sudoers file you just created
sudo visudo -c -f /etc/sudoers.d/alice

# You should see: /etc/sudoers.d/alice: parsed OK
# If there's a syntax error, visudo will report it and you can fix it
```

**Best practice:** Always validate sudoers files with `visudo -c` before relying on them. A syntax error could prevent sudo from working entirely!

6. Test alice's new sudo privileges
```
sudo su - alice

# These should work without password
sudo systemctl status sshd
sudo journalctl -n 20 --no-pager

# This should fail (not in sudoers)
sudo systemctl restart sshd

# Exit back to your user
exit
```

7. Grant alice full sudo access
```
sudo visudo -f /etc/sudoers.d/alice
```

8. Replace the content with:
```
# Allow alice full sudo access with password
alice ALL=(ALL:ALL) ALL
```

8a. Validate the updated sudoers file
```
sudo visudo -c -f /etc/sudoers.d/alice
```

9. Test alice's full sudo access
```
sudo su - alice

# This should work now (will prompt for alice's password)
sudo whoami
# Should output: root

exit
```

## Part 3: Log Rotation with logrotate

Log files can grow indefinitely and fill up disk space, causing system failures. The `logrotate` utility automatically rotates, compresses, and removes old log files to keep the system healthy.

1. View the main logrotate configuration
```
cat /etc/logrotate.conf
```

2. Understand common logrotate directives:
```
weekly          # Rotate logs weekly (daily, monthly also available)
rotate 4        # Keep 4 rotated logs before deleting old ones
create          # Create new empty log file after rotation
compress        # Compress rotated logs with gzip
delaycompress   # Don't compress most recent rotation
missingok       # Don't error if log file is missing
notifempty      # Don't rotate empty log files
```

3. View modular logrotate configurations
```
ls -la /etc/logrotate.d/
```

## Part 4: SSH Configuration

SSH (Secure Shell) is the primary way to access Linux servers remotely. Understanding the SSH configuration allows you to secure your systems, customize connection behavior, and troubleshoot access issues.

1. View the main SSH server configuration
```
sudo cat /etc/ssh/sshd_config | grep -v "^#" | grep -v "^$"
```

2. View the SSH config directory structure
```
ls -la /etc/ssh/
```

Common SSH server configurations:
```
Port 22                          # Default SSH port
PermitRootLogin no              # Disable root login (security best practice)
PasswordAuthentication yes      # Allow password auth (use key-based instead)
PubkeyAuthentication yes        # Enable SSH key authentication
AllowUsers alice bob            # Only allow specific users
MaxAuthTries 3                  # Limit authentication attempts
ClientAliveInterval 300         # Keep connection alive (seconds)
```

3. View your user's authorized public keys. The corresponding private key is allowed to login as your user.
```
cat ~/.ssh/authorized_keys
```

## Part 5: Shell Profiles and Environment Customization

Shell profiles execute when users log in, allowing you to customize the shell environment, set variables, define aliases, and modify the PATH. Understanding profiles helps you create efficient, personalized work environments.

1. Understand the different profile files:
```
# System-wide profiles (affect all users)
/etc/profile              # Executed for login shells
/etc/bashrc or /etc/bash.bashrc  # Executed for interactive shells
/etc/profile.d/*.sh       # Modular system-wide scripts

# User-specific profiles (in home directory)
~/.bash_profile          # Executed for login shells (sources .bashrc)
~/.bashrc                # Executed for interactive non-login shells
~/.bash_logout           # Executed when logging out
```

2. View your current PATH
```
echo $PATH
```

3. View your current shell and profile
```
echo $SHELL
less ~/.bash_profile
```

4. Check current aliases
```
alias
```

## Part 6: Creating Custom Aliases and PATH Modifications

1. Add a custom alias to your bash profile
```
# Backup your bashrc first
cp ~/.bashrc ~/.bashrc.backup

# Add custom aliases
cat << 'EOF' >> ~/.bashrc

# Custom aliases
alias ddate='date "+%Y-%m-%d %H:%M:%S"'
EOF
```

2. Create a custom scripts directory and add it to PATH
```
# Create a directory for your custom scripts
mkdir -p ~/scripts

# Create a simple test script
cat << 'EOF' > ~/scripts/hello
#!/bin/bash
echo "Hello from custom script in PATH!"
echo "Current user: $(whoami)"
echo "Current directory: $(pwd)"
EOF

chmod +x ~/scripts/hello
```

3. Add the custom directory to PATH in your bash profile
```
cat << 'EOF' >> ~/.bash_profile

# Add personal scripts directory to PATH
# note the export command exports the variable to child processes
if [ -d "$HOME/scripts" ]; then
    export PATH="$HOME/scripts:$PATH"
fi
EOF
```

4. Source the profile to apply changes immediately
```
source ~/.bashrc
source ~/.bash_profile
```

**Important:** When you log out and log back in, the profile files are automatically executed, so you don't need to manually source them.

5. Test your new alias
```
ddate
echo $PATH
```

## Part 7: System Tuning with sysctl

The `sysctl` command allows you to view and modify kernel parameters at runtime. These parameters control various aspects of system behavior like networking, memory management, and process limits.

1. View the maximum number of process IDs (PIDs) the system can handle
```
sysctl kernel.pid_max
```

2. View several interesting system parameters
```
# Maximum number of open file descriptors
sysctl fs.file-max

# Maximum number of inode handlers (filesystem metadata)
sysctl fs.inode-max

# View all kernel parameters (there are hundreds!)
sysctl -a | head -n 20
```

3. View network-related parameters
```
# Enable/disable IP forwarding (routing between interfaces)
sysctl net.ipv4.ip_forward

# TCP keepalive time
sysctl net.ipv4.tcp_keepalive_time
```

4. View the sysctl configuration files
```
# Main configuration file
cat /etc/sysctl.conf

# Modular configurations
ls -la /etc/sysctl.d/
```

**Key takeaway:** The `sysctl` command lets you tune kernel behavior without rebooting. Persistent changes are made in `/etc/sysctl.conf` or `/etc/sysctl.d/`. Common use cases include increasing file descriptor limits, tuning network performance, and adjusting shared memory for databases. You don't need to memorize these—just know where to look when you need to optimize system performance.

## Cleanup

1. Remove the test user and sudoers configuration
```
# Exit if you're still logged in as alice
# Then remove the user
sudo userdel -r alice 2>/dev/null || echo "User already removed"
sudo rm -f /etc/sudoers.d/alice
```

2. Remove the scripts directory and backup file
```
rm -rf ~/scripts
rm -f ~/.bashrc.backup
```

3. Optionally restore original bashrc (if you want to remove the alias)
```
# If you want to remove the custom alias from .bashrc, edit it manually
# Or restore from backup if you saved one before the lab
```

## Conclusion

In this lab, you learned about critical system configuration files and directories that every Linux administrator should understand:

- **sudoers and sudoers.d**: Controlling user privileges with granular sudo access, using `visudo` to safely edit configurations, and following best practices by keeping custom rules in `/etc/sudoers.d/`

- **logrotate and logrotate.d**: Understanding how automatic log rotation prevents disk space issues and keeps systems healthy, without needing to memorize complex syntax

- **SSH configuration**: Knowing where SSH server and client configs live (`/etc/ssh/sshd_config` and `~/.ssh/config`) and common security settings like disabling root login and enforcing key authentication

- **Shell profiles**: Customizing user environments with aliases, PATH modifications, and custom functions in `~/.bashrc` and `~/.bash_profile`, and understanding the difference between system-wide (`/etc/profile.d/`) and user-specific configurations

These configuration files form the foundation of system customization and security. The modular `.d` directory approach (sudoers.d, logrotate.d, profile.d) allows you to add configurations without modifying main system files, reducing the risk of errors and making updates cleaner.

As you continue your Linux journey, you'll frequently reference these configurations to grant controlled access, manage system resources, secure remote access, and create efficient work environments. Remember: you don't need to memorize every option—just know where these files live and how to find documentation when you need it.
