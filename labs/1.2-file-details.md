# File Details

In this lab, you’ll build upon your understanding of the Linux filesystem by exploring how files are secured, executed, and linked within the operating system.
System administrators must not only navigate files, but also control who can access them, how they are executed, and how they are referenced across the filesystem.


You’ll learn how to interpret and modify file permissions, create executable scripts, and understand the difference between hard and soft links — two powerful tools for managing data efficiently. Finally, you’ll use the stat command to inspect the low-level details of files, such as their inodes, size, and timestamps, gaining insight into how Linux tracks every object on disk.

By the end of this lab, you will:
Understand Linux file permission structures and how to modify them.
Create and execute custom scripts using your $PATH.
Create, compare, and inspect hard and soft links.
Use stat to analyze file metadata at the filesystem level.


### Estimated Time: 35 Minutes

## Part 1: File Permissions

Each file in Linux has three types of permissions — read (r), write (w), and execute (x) — for three categories: user, group, and others.

1. Create a folder named permissions and navigate to it.
```
mkdir -p permissions && cd permissions
```


1. Create three files, 1.txt, 2.txt, 3.txt
```
touch 1.txt 2.txt 3.txt
# touch {1..3}.txt
```

2. View the permissions of all files ending in .txt
```
ls -l *.txt
```

3. Add execution privileges to 1.txt for all users
```
chmod a+x 1.txt # all three sets of permissions
# chmod +x 1.txt # defaults to all
ls -l
```

4. Add execution to user and remove read from others and group from 1.txt
```
chmod u+x,go-r 1.txt
ls -l
```

5. Remove write permission for other and group on any file ending in .txt
```
chmod og-w *.txt
ls -la *.txt
```

6. Change 1.txt to allow all permisions for all users
```
chmod 777 1.txt
```

7. Update 2.txt and 3.txt to have the default permissions of 644
```
chmod 644 2.txt 3.txt
# chmod 644 {2..3}.txt
```

> What’s one difference between file permissions and ownership, and how might each impact security?

## Part 2: File Execution 

Executing a file means running a program or script so that the kernel allocates resources, loads it into memory, and assigns it a process ID (PID) in the system’s process table.

The `$PATH` variable defines a list of directories that the shell searches when you run a command. If a file’s directory is included in `$PATH`, you can execute it from anywhere without specifying its full path.

1. Run the command below to create a file named ~/scripts/print.sh
    ```
    mkdir -p ~/scripts
    cat << EOF > ~/scripts/print.sh
    #! /bin/bash
    echo $1
    EOF
    ```
2.  Make the file executable and run it.
   ```
   chmod +x ~/scripts/print.sh
   cd ~/scripts
   ./print.sh
   cd ~
   ./scripts/print.sh # fails
   ```

3. Print the $PATH variable. Copy the ~/scripts/print.sh into a path in the path variable. You will now be able to run print.sh no matter your working directory.
```
echo $PATH
# Example Output:
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/home/ec2-user/bin

# Place print.sh in $HOME/bin to make it executable only for your user (ec2-user)
# Place print.sh in /usr/local/bin or /usr/bin to make it executable for all users
# Example:
mkdir -p ~/bin
cp ~/scripts/print.sh ~/bin/
chmod +x ~/bin/print.sh
print.sh "Sending a message"# Run print.sh

```

## Part 3: Linking Files

Sometimes you need multiple names or references to the same file — for example, to organize data, create shortcuts, or share access without duplicating content.
Linux provides two main types of links: hard links and soft links (symbolic links).

Both let you access the same data, but they behave differently when the original file is moved or deleted.

**Hard Link** – Points directly to the same inode (data) as the original file. Deleting one does not remove the content until all links are deleted.

**Soft Link (Symbolic Link)** – Points to a file path, not the data itself. Works like a shortcut and breaks if the original file is deleted or moved.

1. Create a hard link and notice how the **inode** numbers are the same. Remember, **inode** number is a unique id for a file.
```
ln ~/scripts/print.sh ~/scripts/print_copy.sh
ls -li ~/scripts
```
2. Create a soft link and compare the inodes.
```
# Create a soft link
ln -s ~/scripts/print.sh ~/scripts/print_link.sh
ls -li ~/scripts
```
3. Stat all of.sh files in scripts.
```
stat ~/scripts/print*.sh
```

Consider this example output
```
  File: /home/ec2-user/scripts/print.sh
  Size: 40          Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d  Inode: 1332515     Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (1000/ec2-user)  Gid: (1000/ec2-user)
Access: 2025-10-18 13:20:51.000000000 -0600
Modify: 2025-10-18 13:15:42.000000000 -0600
Change: 2025-10-18 13:15:42.000000000 -0600
 Birth: -

```

Size: The file’s size in bytes (40 in this case).  
Blocks / IO Block: How much space the file occupies on disk (8 blocks of 4096 bytes each).  
Inode: The unique identifier for this file on the filesystem — two files with the same inode are hard links.  
Links: The number of hard links pointing to this file.  
Access (permissions): Shows both the numeric (0755) and symbolic (-rwxr-xr-x) permission formats.  
UID/GID: The owner and group IDs, along with the corresponding usernames.  
Timestamps:  
Access: Last time the file was read.  
Modify: Last time the contents were changed.  
Change: Last time the metadata (permissions, owner, etc.) was modified.  

4. Save the output of stat to a file in scripts and make changes to the file with a text editor.
```
stat ~/scripts/print.sh > ~/scripts/print.stat
vim ~/scripts/print.stat
# use i to enter insert mode
# make changes to file
# use esc, then ZZ to exit and save the file
```

## Part 4: Bonus Challenge
The Backup Script:

Your task is to create a small backup utility using what you’ve learned.

1. Create a script called backup.sh in ~/scripts that copies any file passed as an argument into a folder called ~/backups.
Example: ./backup.sh notes.txt should copy notes.txt into ~/backups/notes.txt.
2. Make backup.sh executable and add it to your $PATH so it can be run from anywhere.
3. Create both a hard link and a symbolic link to backup.sh in your home directory.
4. Use the stat command to compare all three and note how their inodes and permissions differ.


## Cleanup
**Be careful, the commands below are destructive.** The -r option is for recursive, required for directories.
```
rm -ri ~/scripts
rm -ri ~/permissions
```

# Conclusion

In this lab, you deepened your understanding of how Linux manages files beyond simple navigation — focusing on permissions, execution, and linking.
You learned how to:

- Interpret and modify file permissions using both symbolic (u+x, go-r) and numeric (644, 777) modes.
- Create and execute scripts, and configure your $PATH to make personal commands available system-wide or user-specific.
- Understand how hard links share the same inode and data, while soft links reference a file path and break if the target is removed.
- Use the stat command to view detailed metadata, such as file size, ownership, timestamps, and inode relationships.

These are core skills for every system administrator — knowing not just where files are, but how they behave at the filesystem level.
Mastering these tools builds the foundation for secure, efficient management of Linux systems and prepares you for advanced topics like user administration, service control, and system architecture.
