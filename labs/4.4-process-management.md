# Advanced Process Management

Process management extends beyond starting and stopping processes. Understanding how processes interact with files, managing process priority, handling orphaned processes, and controlling resource allocation through cgroups are critical skills for production system administration.

When troubleshooting issues like "file is busy" errors, identifying which process has a file open, or managing resource-intensive applications, these advanced process management techniques become essential. Modern containerization and orchestration systems rely heavily on cgroups for resource isolation, making basic cgroup knowledge increasingly important.

This lab builds upon foundational process monitoring skills by exploring file descriptors, process relationships, priority management, and Linux control groups (cgroups).

### Estimated Time: 40 Minutes

## Part 1: Understanding Process File Descriptors with lsof

The `lsof` (List Open Files) command reveals which files, sockets, and resources a process is using. Remember: in Linux, everything is a fileâ€”including network sockets, pipes, and devices.

1. Create a workspace and explore basic lsof usage
```bash
mkdir -p ~/process_mgmt && cd ~/process_mgmt

# Start a simple process that we can examine
sleep 300 > output.txt &
SLEEP_PID=$!
echo "Sleep process PID: $SLEEP_PID"
```

2. Examine all files opened by a specific process
```bash
# View all open files for our sleep process
lsof -p $SLEEP_PID

# Notice the output columns:
# COMMAND: Process name
# PID: Process ID
# USER: Process owner
# FD: File descriptor (0=stdin, 1=stdout, 2=stderr, numbers=open files)
# TYPE: Type of file (REG=regular file, DIR=directory, CHR=character device)
# DEVICE: Device numbers
# SIZE/OFF: File size or offset
# NODE: Inode number
# NAME: Filename or resource name
```

3. Understanding what the output reveals
```bash
# The executable file used to create the process is shown with txt (text/code)
# You'll see entries like:
# - /usr/bin/sleep (txt) - the binary that's executing
# - /lib64/libc.so.6 (mem) - shared libraries loaded in memory
# - output.txt (1w) - file descriptor 1 (stdout) opened for writing

# Filter to see just regular files (not libraries)
lsof -p $SLEEP_PID | grep -E "REG|NAME"
```

4. Create a test file and find which process has it open
```bash
# Start a process that keeps a file open
tail -f output.txt &
TAIL_PID=$!

# Find which processes have output.txt open
lsof output.txt

# This shows all processes accessing this file
# Useful when you get "file is busy" or can't delete a file

# Clean up
kill $TAIL_PID $SLEEP_PID
```

5. Practical lsof scenarios
```bash
# Find all files opened by your current user
lsof -u $USER | head -20

# Find processes listening on network ports
lsof -i -P -n

# Find what process is using a specific port
# lsof -i :22  # SSH port example

# Find all processes accessing a specific directory
touch test_file.txt
cat test_file.txt &
CAT_PID=$!
lsof +D ~/process_mgmt | head -10
kill $CAT_PID 2>/dev/null
```

## Part 2: Understanding ps Command Headers

The `ps` command provides detailed process information. Understanding key headers helps you diagnose system issues effectively.

1. Explore important ps output fields
```bash
# Start some test processes
sleep 1000 &
sleep 2000 &
dd if=/dev/zero of=/dev/null &
DD_PID=$!

# Display key process metrics
ps -eo pid,ppid,user,pri,ni,vsz,rss,pmem,pcpu,stat,time,cmd | grep -E "PID|sleep|dd" | head -10
```

2. Understanding key headers:
```bash
# PID    = Process ID
# PPID   = Parent Process ID (who started this process)
# USER   = Process owner
# PRI    = Priority (kernel's scheduling priority, higher = higher priority)
# NI     = Nice value (-20 to 19, lower = higher priority)
# VSZ    = Virtual memory size (KB) - total memory allocated
# RSS    = Resident Set Size (KB) - physical RAM currently used
# %MEM   = Percentage of physical memory used
# %CPU   = Percentage of CPU time used
# STAT   = Process state (R=running, S=sleeping, D=uninterruptible sleep, Z=zombie, T=stopped)
# TIME   = Total CPU time consumed
# CMD    = Command that started the process

# View process states in detail
ps aux | grep -E "STAT|sleep|dd" | head -10

# STAT codes explained:
# R = Running or runnable (on run queue)
# S = Interruptible sleep (waiting for an event)
# D = Uninterruptible sleep (usually I/O)
# T = Stopped (by job control signal)
# Z = Zombie (terminated but not cleaned up by parent)
# Additional flags: < = high-priority, N = low-priority, + = in foreground process group
```

3. Find parent-child process relationships
```bash
# Create a parent-child relationship
bash -c 'sleep 5000 & sleep 6000 &' &
BASH_PID=$!

# View process tree
ps -ef --forest | grep -A 5 $BASH_PID

# Or use pstree for better visualization
pstree -p $BASH_PID

# Clean up
kill $BASH_PID $DD_PID 2>/dev/null
pkill -P $BASH_PID 2>/dev/null
```

## Part 3: Process Priority with nice and renice

Process priority determines how much CPU time the kernel allocates to a process. The "nice" value ranges from -20 (highest priority) to 19 (lowest priority). The default is 0.

1. Understanding and setting nice values
```bash
# Start a normal priority CPU-intensive process
dd if=/dev/zero of=/dev/null &
NORMAL_PID=$!

# Check its nice value and priority
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Start a low-priority (nice) process
nice -n 10 dd if=/dev/zero of=/dev/null &
NICE_PID=$!

# Start a high-priority process (requires sudo for negative nice)
sudo nice -n -10 dd if=/dev/zero of=/dev/null &
HIGH_PID=$!

# Compare priorities
ps -o pid,ni,pri,pcpu,cmd -p $NORMAL_PID,$NICE_PID,$HIGH_PID

# Watch CPU distribution (you may need to let them run a few seconds)
sleep 3
ps -o pid,ni,pcpu,cmd -p $NORMAL_PID,$NICE_PID,$HIGH_PID
```

2. Changing priority of running processes with renice
```bash
# Change priority of running process (make it nicer/lower priority)
renice -n 15 -p $NORMAL_PID

# Check the change
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Increase priority (requires sudo)
sudo renice -n -5 -p $NORMAL_PID

# Verify change
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Clean up CPU-intensive processes
kill $NORMAL_PID $NICE_PID 2>/dev/null
sudo kill $HIGH_PID 2>/dev/null
```

3. Practical use cases for nice/renice
```bash
# Run a backup script with low priority so it doesn't impact performance
nice -n 19 tar -czf backup.tar.gz ~/process_mgmt 2>/dev/null &
BACKUP_PID=$!

# Monitor its impact
ps -o pid,ni,pcpu,cmd -p $BACKUP_PID

# Wait for it and clean up
wait $BACKUP_PID 2>/dev/null
rm -f backup.tar.gz
```

## Part 4: Understanding Orphaned Processes

When a parent process dies before its children, those children become "orphaned" and are adopted by the init process (PID 1, typically systemd).

1. Create an orphaned process scenario
```bash
# Create a script that spawns a child and exits
cat << 'EOF' > parent.sh
#!/bin/bash
echo "Parent PID: $$"
# Start child process that will outlive parent
(sleep 300; echo "Child finished") &
CHILD_PID=$!
echo "Child PID: $CHILD_PID"
# Parent exits immediately, orphaning the child
EOF

chmod +x parent.sh
./parent.sh
```

2. Observe the orphaned process
```bash
# Find the orphaned sleep process
ps -eo pid,ppid,stat,cmd | grep [s]leep

# Notice PPID is now 1 (or your init system's PID)
# The orphaned process has been re-parented to init/systemd

# Find it and examine
ORPHAN_PID=$(pgrep -f "sleep 300")
if [ -n "$ORPHAN_PID" ]; then
    echo "Orphaned process PID: $ORPHAN_PID"
    ps -o pid,ppid,stat,cmd -p $ORPHAN_PID
    # Clean up
    kill $ORPHAN_PID
fi
```

3. Understanding zombie processes
```bash
# Create a zombie process (child exits but parent doesn't read status)
cat << 'EOF' > zombie_maker.sh
#!/bin/bash
# Child process that exits immediately
bash -c 'exit 0' &
CHILD_PID=$!
echo "Created child with PID: $CHILD_PID"
echo "Parent ($$) sleeping for 30 seconds without cleaning up child..."
sleep 30
echo "Parent exiting"
EOF

chmod +x zombie_maker.sh
./zombie_maker.sh &
ZOMBIE_PARENT=$!

# Quickly check for zombie (look for Z or <defunct>)
sleep 2
ps aux | grep -E "defunct|Z"
ps -o pid,ppid,stat,cmd | grep -E "STAT|Z"

# Zombies are cleaned up when parent exits or calls wait()
wait $ZOMBIE_PARENT 2>/dev/null
```

## Part 5: Introduction to Control Groups (cgroups)

Control groups (cgroups) allow you to allocate and limit system resources (CPU, memory, I/O) for groups of processes. This is the foundation of container resource management.

1. Explore existing cgroups on your system
```bash
# View cgroup mount point (usually /sys/fs/cgroup)
mount | grep cgroup

# Examine cgroup hierarchy (systemd manages cgroups on modern systems)
ls /sys/fs/cgroup/

# Look at systemd's cgroup structure
systemctl status | head -20

# View cgroup information for a running process
cat /proc/self/cgroup
```

2. Examine a cgroup's resource limits
```bash
# Look at current user's session cgroup
SESSION_CGROUP=$(cat /proc/self/cgroup | grep "^0:" | cut -d: -f3)
echo "Your session cgroup: $SESSION_CGROUP"

# View memory limits for a cgroup (if available)
# This might vary based on cgroup v1 vs v2
if [ -f /sys/fs/cgroup/memory.max ]; then
    # cgroup v2
    cat /sys/fs/cgroup/memory.max
elif [ -f /sys/fs/cgroup/memory/memory.limit_in_bytes ]; then
    # cgroup v1
    cat /sys/fs/cgroup/memory/memory.limit_in_bytes
fi

# View current memory usage of your session
if [ -f /sys/fs/cgroup/memory.current ]; then
    # cgroup v2
    echo "Current memory usage (bytes):"
    cat /sys/fs/cgroup/memory.current
fi
```

3. Create a simple cgroup with systemd-run
```bash
# Run a command in a transient cgroup with memory limit
# This creates a temporary cgroup that's cleaned up when the command exits
sudo systemd-run --unit=hello-cgroup --slice=user-test \
    --property=MemoryMax=50M \
    /bin/bash -c 'echo "Hello from cgroup!"; sleep 10' &

# Give it a moment to start
sleep 2

# View the running unit
systemctl status hello-cgroup --no-pager

# Examine the cgroup for this unit
systemctl show hello-cgroup --property=ControlGroup --no-pager

# View the cgroup's memory limit
CGROUP_PATH=$(systemctl show hello-cgroup --property=ControlGroup --no-pager | cut -d= -f2)
echo "Cgroup path: $CGROUP_PATH"

# Wait for it to complete
sleep 10
```

4. Create a CPU-limited cgroup
```bash
# Run a CPU-intensive task with CPU quota (50% of one core)
sudo systemd-run --unit=cpu-limited --slice=user-test \
    --property=CPUQuota=50% \
    /bin/bash -c 'dd if=/dev/zero of=/dev/null & sleep 15' &

sleep 2

# Monitor its CPU usage (should be limited to ~50%)
watch -n 1 'ps aux | grep -E "PID|cpu-limited"'
# Press Ctrl+C after observing

# Check the unit status
systemctl status cpu-limited --no-pager

# Wait for completion
sleep 15
```

5. Understanding cgroup practical applications
```bash
# Cgroups are used by:
# - Docker/Podman: Each container runs in its own cgroup
# - Kubernetes: Resource limits (requests/limits) use cgroups
# - Systemd services: Service units have resource controls

# View resource limits for the SSH service
systemctl show sshd --property=MemoryLimit,CPUQuota --no-pager 2>/dev/null || \
systemctl show ssh --property=MemoryLimit,CPUQuota --no-pager 2>/dev/null

echo ""
echo "Cgroups enable:"
echo "- Resource isolation (containers)"
echo "- Resource limits (prevent runaway processes)"
echo "- Resource accounting (track usage per service)"
echo "- Quality of service (prioritize critical services)"
```

## Cleanup
```bash
# Kill any remaining background processes
pkill -f "sleep [0-9]" 2>/dev/null
cd ~
rm -rf ~/process_mgmt
```

## Conclusion

In this lab, you've gained advanced process management skills essential for production Linux administration:

- **lsof mastery**: Identifying open files, sockets, and file descriptors for any process, and discovering which processes have specific files open
- **ps interpretation**: Understanding critical process metrics like PRI, NI, VSZ, RSS, and STAT codes to diagnose system behavior
- **Process priority**: Managing CPU allocation with nice and renice to balance system load
- **Process lifecycle**: Understanding orphaned processes, zombie processes, and parent-child relationships
- **cgroups fundamentals**: Viewing cgroup hierarchies, examining resource limits, and creating basic resource-controlled processes with systemd-run

These advanced techniques are crucial for:
- Troubleshooting "file is busy" errors and locked files
- Investigating resource consumption and performance issues
- Managing system load during maintenance windows
- Understanding how modern container runtimes work
- Implementing resource controls in production environments

The skills you've learned here form the foundation for understanding how Docker, Kubernetes, and other containerization technologies manage resources and isolate workloads. As you progress in your Linux administration journey, these concepts will become increasingly important for managing complex, multi-tenant systems.
