# Task Scheduling

Automated task scheduling is essential for system administration. Whether you need to run backups, clean up temporary files, rotate logs, or perform system maintenance, Linux provides powerful scheduling tools to execute tasks at specific times or intervals.

The two primary scheduling systems in modern Linux are cron (the traditional Unix scheduler) and systemd timers (the modern alternative). Understanding both is important, as you'll encounter cron in legacy systems and systemd timers in modern distributions.

This lab introduces the fundamentals of both scheduling systems, including syntax, creating simple scheduled tasks, and proper cleanup to prevent resource issues.

### Estimated Time: 20 Minutes

## Part 1: Understanding Cron Scheduling

Cron uses a simple but powerful syntax to define when tasks should run. Each cron job is defined by a time specification followed by the command to execute.

1. Understanding cron syntax
```bash
# Cron syntax: minute hour day month weekday command
# Each field can contain:
# - A number (e.g., 5)
# - A range (e.g., 1-5)
# - A list (e.g., 1,3,5)
# - An asterisk * (meaning "every")
# - A step value (e.g., */5 means "every 5")

# Field positions:
# ┌───────────── minute (0-59)
# │ ┌───────────── hour (0-23)
# │ │ ┌───────────── day of month (1-31)
# │ │ │ ┌───────────── month (1-12)
# │ │ │ │ ┌───────────── day of week (0-6, Sunday=0)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * command to execute

# Examples:
# 0 2 * * *           - Run at 2:00 AM every day
# */15 * * * *        - Run every 15 minutes
# 0 0 * * 0           - Run at midnight every Sunday
# 30 3 1 * *          - Run at 3:30 AM on the 1st of every month
# 0 9-17 * * 1-5      - Run at the top of every hour from 9 AM to 5 PM, Monday-Friday
```

2. View existing cron jobs
```bash
# View your personal crontab (likely empty initially)
crontab -l

# This may show "no crontab for user" if you haven't created one yet
```

3. Create your first cron job
```bash
# Open crontab editor (will create a new crontab if none exists)
crontab -e

# If prompted for an editor, choose nano or vi based on your preference
# Add this line to run every minute (for testing):
# * * * * * echo "Cron ran at: $(date)" >> /tmp/cron_test.log

# Save and exit:
# - In nano: Ctrl+O (save), Enter, Ctrl+X (exit)
# - In vi: Esc, :wq, Enter
```

4. Verify and monitor your cron job
```bash
# Confirm the crontab was saved
crontab -l

# Wait about 2 minutes and check the output
sleep 120
cat /tmp/cron_test.log

# You should see a new entry every minute
tail -f /tmp/cron_test.log
```

5. Check cron system logs
```bash
# View recent cron activity in system logs
sudo journalctl -u crond -n 20 --no-pager 2>/dev/null || \
sudo journalctl -u cron -n 20 --no-pager
```

6. **IMPORTANT: Clean up cron jobs immediately**
```bash
# Remove all cron jobs to prevent filling up tmp folder
crontab -r

# Verify crontab is removed
crontab -l

# Clean up the test log file
rm -f /tmp/cron_test.log
```

## Part 2: Systemd Timers (Modern Scheduling)

Systemd timers are the modern alternative to cron, offering better logging, dependencies, and integration with systemd services. They're more verbose but more powerful and easier to debug.

### Why Systemd Timers are Better:

- **Better logging**: Integrated with journalctl, easier to debug
- **Dependencies**: Can depend on other services or system states
- **Resource control**: Can use cgroups for resource limits
- **Flexible timing**: Calendar events and monotonic timers
- **Failure handling**: Automatic retry, failure notifications
- **No emails**: Output goes to journal, not random emails

1. Understanding systemd timer components
```bash
# A systemd timer requires TWO files:
# 1. A .service file - defines WHAT to run
# 2. A .timer file - defines WHEN to run it

# Let's create a simple hello world example
mkdir -p ~/scheduling_demo && cd ~/scheduling_demo
```

2. Create a simple service file
```bash
# Create a service that writes to a log file
cat << 'EOF' > hello-timer.service
[Unit]
Description=Hello World Timer Demo
Documentation=man:systemd.service(5)

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'echo "Hello from systemd timer at $(date)" >> /tmp/systemd_timer.log'
EOF

# Type=oneshot means the service runs once and exits
# Perfect for scheduled tasks
```

3. Create the corresponding timer file
```bash
# Create a timer that runs every minute
cat << 'EOF' > hello-timer.timer
[Unit]
Description=Run Hello World Every Minute
Documentation=man:systemd.timer(5)

[Timer]
# Run 1 minute after boot
OnBootSec=1min
# Then run every minute
OnUnitActiveSec=1min
# Alternative: Use calendar events (like cron)
# OnCalendar=*:0/1
# This means: every minute

[Install]
WantedBy=timers.target
EOF
```

4. Understanding timer time specifications
```bash
# Systemd timers support two types of timing:

# Monotonic timers (relative to system events):
# OnBootSec=5min          - 5 minutes after boot
# OnStartupSec=10min      - 10 minutes after systemd starts
# OnActiveSec=1h          - 1 hour after timer activates
# OnUnitActiveSec=30min   - 30 minutes after service last ran

# Calendar events (absolute time, like cron):
# OnCalendar=daily                    - Every day at midnight
# OnCalendar=weekly                   - Every Monday at midnight
# OnCalendar=*-*-* 02:00:00          - Every day at 2 AM
# OnCalendar=Mon *-*-* 09:00:00      - Every Monday at 9 AM
# OnCalendar=*:0/15                   - Every 15 minutes
# OnCalendar=*-*-01 03:00:00         - 1st of every month at 3 AM

# Time units: us, ms, s, min, h, d, w, M, y
```

5. Install and start the timer
```bash
# Copy service and timer files to systemd user directory
mkdir -p ~/.config/systemd/user
cp hello-timer.service hello-timer.timer ~/.config/systemd/user/

# Reload systemd to recognize new files
systemctl --user daemon-reload

# Start and enable the timer
systemctl --user start hello-timer.timer
systemctl --user enable hello-timer.timer

# Check timer status
systemctl --user status hello-timer.timer

# List all active timers
systemctl --user list-timers
```

6. Monitor the timer execution
```bash
# Wait a couple minutes for the timer to run
sleep 130

# Check the output file
cat /tmp/systemd_timer.log

# View service execution logs
journalctl --user -u hello-timer.service -n 10 --no-pager

# Check when the timer will run next
systemctl --user list-timers hello-timer.timer
```

7. Manually trigger the service (useful for testing)
```bash
# Run the service immediately without waiting for timer
systemctl --user start hello-timer.service

# Check it ran
tail -2 /tmp/systemd_timer.log

# View the most recent log entry
journalctl --user -u hello-timer.service -n 1 --no-pager
```

8. **Clean up systemd timer**
```bash
# Stop and disable the timer
systemctl --user stop hello-timer.timer
systemctl --user disable hello-timer.timer

# Remove the service files
rm ~/.config/systemd/user/hello-timer.{service,timer}

# Reload systemd
systemctl --user daemon-reload

# Verify timer is gone
systemctl --user list-timers

# Clean up log file
rm -f /tmp/systemd_timer.log

# Clean up demo directory
cd ~
rm -rf ~/scheduling_demo
```

## Part 3: Quick Comparison

```bash
# Display a comparison of cron vs systemd timers
cat << 'EOF'
╔══════════════════════════════════════════════════════════════════╗
║               CRON vs SYSTEMD TIMERS COMPARISON                  ║
╠══════════════════════════════════════════════════════════════════╣
║ Feature          │ Cron              │ Systemd Timers            ║
╠══════════════════════════════════════════════════════════════════╣
║ Syntax           │ Simple            │ More verbose              ║
║ Logging          │ Mail/syslog       │ Journalctl (better!)      ║
║ Debugging        │ Difficult         │ Easy with systemctl       ║
║ Dependencies     │ None              │ Full systemd integration  ║
║ Failure handling │ Basic             │ Advanced (restart, etc)   ║
║ Resource limits  │ No                │ Yes (cgroups)             ║
║ Random delays    │ No                │ Yes (RandomizedDelaySec)  ║
║ Boot behavior    │ No built-in       │ OnBootSec, OnStartupSec   ║
║ User jobs        │ crontab -e        │ systemctl --user          ║
║ When to use      │ Simple tasks      │ Complex system services   ║
║                  │ Legacy systems    │ Modern distributions      ║
╚══════════════════════════════════════════════════════════════════╝

RECOMMENDATION: Use systemd timers for new projects on modern systems.
Use cron for simple personal scripts or on systems without systemd.
EOF
```

## Practical Examples Reference

```bash
# Common cron patterns:
# 0 0 * * * /usr/local/bin/daily_backup.sh           # Daily at midnight
# 0 2 * * 0 /usr/local/bin/weekly_cleanup.sh         # Weekly Sunday 2 AM
# */10 * * * * /usr/local/bin/check_services.sh      # Every 10 minutes
# 0 */4 * * * /usr/local/bin/log_rotation.sh         # Every 4 hours

# Common systemd timer patterns:
# OnCalendar=daily                                     # Daily at midnight
# OnCalendar=weekly                                    # Weekly Monday midnight
# OnCalendar=*:0/10                                    # Every 10 minutes
# OnCalendar=*-*-* 0/4:00:00                          # Every 4 hours
```

## Conclusion

In this lab, you learned the fundamentals of task scheduling in Linux:

- **Cron basics**: Understanding the five-field time syntax and creating simple cron jobs
- **Cron management**: Using `crontab -e`, `crontab -l`, and `crontab -r` to manage scheduled tasks
- **Systemd timers**: Creating service and timer units for more robust scheduling
- **Timer types**: Understanding monotonic timers and calendar events
- **Monitoring**: Viewing cron logs and using journalctl for systemd timer debugging
- **Best practices**: Proper cleanup to prevent resource issues

Key takeaways:
- Always clean up test cron jobs with `crontab -r` to prevent resource waste
- Systemd timers are more powerful and easier to debug than cron
- Use cron for simple personal scripts on any Linux system
- Use systemd timers for production services on modern distributions
- Both tools are widely used, so understanding both is important

These scheduling skills enable you to automate routine maintenance tasks, system backups, log rotation, monitoring scripts, and any other recurring operations essential for Linux system administration.
