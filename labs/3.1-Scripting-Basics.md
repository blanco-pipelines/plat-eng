# Linux – Shell Scripting

Shell scripting is the foundation of automation in Linux system administration. Scripts allow you to combine multiple commands into reusable programs that can automate repetitive tasks, configure systems, and solve complex problems efficiently.

Bash (Bourne Again Shell) is the most common shell on Linux systems. Understanding how to write effective shell scripts—including variables, conditionals, loops, and error handling—transforms you from someone who types commands to someone who builds automation solutions.

Mastering shell scripting is essential for system administrators because it enables you to automate deployments, manage configurations, process logs, and create tools that make your work more efficient and reliable.

### Estimated Time: 25 Minutes

## Part 1: Creating Your First Script

1. Create a practice directory for your scripts
```
mkdir -p ~/scripting_practice && cd ~/scripting_practice
```

2. Create your first script
```
vi hello.sh
```

3. Add the following content:
```sh
#!/bin/bash
# My first shell script
echo "Hello, World!"
echo "Current date: $(date)" 
echo "Current user: $(whoami)"
```

4. Make the script executable and run it
```
chmod +x hello.sh
./hello.sh
```

## Part 2: Variables and Special Variables

1. Create a script to explore variables
```
vi variables.sh
```

2. Add this content to understand special variables:
```sh
#!/bin/bash
# Understanding variables and special variables

# Regular variables
NAME="Linux Admin"
COUNT=5

echo "Regular variable: $NAME"
echo "Numeric variable: $COUNT"
echo ""

# Special variables
echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "Number of arguments: $#"
echo "All arguments (as string): $@"
echo "Process ID: $$"
echo "Exit status of last command: $?"
```

3. Make executable and test with arguments
```
chmod +x variables.sh
./variables.sh arg1 arg2 arg3
```

**Special Variables Explained:**
- `$0` - The name of the script itself
- `$1, $2, $3...` - Positional parameters (arguments passed to the script)
- `$#` - Count of arguments passed to the script
- `$@` - All arguments as separate strings
- `$$` - Process ID (PID) of the current script
- `$?` - Exit status of the last command (0 = success, non-zero = error)

## Part 3: Reading User Input

1. Create a script for user interaction
```
vi user_input.sh
```

2. Add this content:
```sh
#!/bin/bash
# Reading user input

echo "Enter your username:"
read username

echo "Enter your age:"
read age

echo ""
echo "Hello, $username! You are $age years old."
```

3. Make executable and run it
```
chmod +x user_input.sh
./user_input.sh
```

## Part 4: Conditional Statements

Notice below the if conditions use options such as -z, -f, -r, etc. 
To see what these options do use `man test`

1. Create a file checking script
```
vi check_file.sh
```

2. Write a script that demonstrates testing if a file exists. Remember, `[]` is an alias for the `test` command.
```sh
#!/bin/bash
# Conditional statements - different syntaxes

filename=$1

if [ -z "$filename" ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

# Using 'test' command
if test -f "$filename"; then
    echo "[test command] File exists: $filename"
else
    echo "[test command] File does not exist: $filename"
fi

# Using [ ] (same as test)
if [ -f "$filename" ]; then
    echo "[single brackets] File exists: $filename"
else
    echo "[single brackets] File does not exist: $filename"
fi

# Using [[ ]] (modern bash syntax, recommended)
if [[ -f "$filename" ]]; then
    echo "[double brackets] File exists: $filename"
    
    if [[ -r "$filename" ]]; then
        echo "  - File is readable"
    fi
    
    if [[ -w "$filename" ]]; then
        echo "  - File is writable"
    fi
    
    if [[ -x "$filename" ]]; then
        echo "  - File is executable"
    fi
else
    echo "[double brackets] File does not exist: $filename"
fi
```

3. Test the script with different files
```
chmod +x check_file.sh
touch testfile.txt
./check_file.sh testfile.txt
./check_file.sh nonexistent.txt
```

**Note:** `[[ ]]` aka, extended test command, is the modern, recommended syntax for Bash conditionals. It's more powerful and handles edge cases better than `[ ]` or `test`.

## Part 5: Loops

1. Create a script with a basic while loop
```
vi counter.sh
```

2. Add this content:
```sh
#!/bin/bash
# Basic while loop example

count=1

echo "Counting to 5..."
while [[ $count -le 5 ]]; do
    echo "Count: $count"
    count=$((count + 1))
done

echo "Done!"
```

3. Make executable and run it
```
chmod +x counter.sh
./counter.sh
```

## Part 6: For Loops

1. Create a script with a basic for loop
```
vi for_loop.sh
```

2. Add this content to iterate over a list of items:
```sh
#!/bin/bash
# Basic for loop examples

echo "=== Iterating over a list of words ==="
for item in apple banana cherry; do
    echo "Fruit: $item"
done

echo ""
echo "=== Iterating over numbers ==="
for num in 1 2 3 4 5; do
    echo "Number: $num"
done

echo ""
echo "=== Using brace expansion for ranges ==="
for i in {1..5}; do
    echo "Count: $i"
done

echo ""
echo "=== Iterating over files ==="
for file in *.sh; do
    echo "Script file: $file"
done
```

3. Make executable and run it
```
chmod +x for_loop.sh
./for_loop.sh
```

4. Create a more practical example - processing command-line arguments
```
vi process_args.sh
```

5. Add this content:
```sh
#!/bin/bash
# Process all command-line arguments with a for loop

echo "Processing $# arguments..."
echo ""

for arg in "$@"; do
    echo "Argument: $arg"
done

echo ""
echo "Done!"
```

6. Test with multiple arguments
```
chmod +x process_args.sh
./process_args.sh one two three "four and five"
```

7. Create a C-style for loop example
```
vi c_style_loop.sh
```

8. Add this content:
```sh
#!/bin/bash
# C-style for loop (alternative syntax)

echo "=== C-style for loop ==="
for ((i=1; i<=5; i++)); do
    echo "Iteration $i"
done

echo ""
echo "=== Counting down ==="
for ((i=5; i>=1; i--)); do
    echo "Countdown: $i"
done

echo "Liftoff!"
```

9. Make executable and run it
```
chmod +x c_style_loop.sh
./c_style_loop.sh
```

**For Loop Syntax Options:**
- `for item in list` - Iterate over space-separated items
- `for file in *.txt` - Iterate over files matching a pattern
- `for i in {1..10}` - Iterate over a range (brace expansion)
- `for ((i=0; i<10; i++))` - C-style loop with initialization, condition, increment

## Part 7: Error Handling with set Options

1. Create a script to demonstrate error handling
```
vi error_handling.sh
```

2. Add this content:
```sh
#!/bin/bash
# Error handling with set options

# Exit on error - script stops if any command fails
set -e

# Exit on undefined variables
set -u

# Exit on pipe failures (not just the last command)
set -o pipefail

echo "Starting script with error handling..."

# This will succeed
echo "Step 1: Creating directory"
mkdir -p /tmp/test_directory

# This will succeed
echo "Step 2: Creating file"
touch /tmp/test_directory/test.txt

# Try to list the file
echo "Step 3: Listing file"
ls /tmp/test_directory/test.txt

echo "Script completed successfully!"
```

3. Make executable and run it
```
chmod +x error_handling.sh
./error_handling.sh
```

4. Now create a script that shows what happens with errors
```
vi error_demo.sh
```

5. Add this content:
```sh
#!/bin/bash
# Demonstrating error handling

echo "=== Without set -e ==="
mkdir /tmp/testdir 2>/dev/null
echo "This line runs even if mkdir failed"
echo ""

echo "=== With set -e ==="
set -e
mkdir /tmp/testdir  # This might fail if directory exists
echo "This line only runs if mkdir succeeded"
```

6. Test it
```
chmod +x error_demo.sh
./error_demo.sh
```

**Error Handling Options Explained:**
- `set -e` - Exit immediately if any command fails (returns non-zero status)
- `set -u` - Treat undefined variables as errors
- `set -o pipefail` - Return failure status if any command in a pipeline fails, not just the last one

These options help create robust scripts that fail fast and clearly when something goes wrong.

## Part 8: Practical Example

1. Create a system information script
```
vi sysinfo.sh
```

2. Combine concepts into a practical script:
```sh
#!/bin/bash
set -e
set -u

# System information script

echo "=== System Information Report ==="
echo "Generated on: $(date)"
echo "Generated by: $(whoami)"
echo "Hostname: $(hostname)"
echo ""

echo "=== Disk Usage ==="
df -h / | tail -n 1
echo ""

echo "=== Memory Usage ==="
free -h | grep Mem
echo ""

echo "=== CPU Load ==="
uptime
echo ""

# Check if log directory exists
if [[ -d /var/log ]]; then
    echo "=== Recent Log Files ==="
    ls -lht /var/log | head -n 5
fi

echo ""
echo "Report complete!"
```

3. Make executable and run it
```
chmod +x sysinfo.sh
./sysinfo.sh
```

## Cleanup
```
cd ~
rm -rf ~/scripting_practice
```

## Conclusion

In this lab, you learned the fundamentals of Bash scripting for Linux system administration:

- **Script basics**: Creating executable scripts with proper shebang and permissions
- **Variables**: Using regular variables and special variables ($1, $#, $@, $$, $?)
- **User input**: Reading data from users with the read command
- **Conditionals**: Using test, [ ], and [[ ]] for decision making (prefer [[ ]])
- **Loops**: Implementing while loops for repetitive tasks
- **Error handling**: Using set -e, set -u, and set -o pipefail for robust scripts

Shell scripting is a critical skill that enables you to automate tasks, build tools, and solve problems efficiently. These fundamentals form the foundation for creating more complex automation solutions in your daily work as a system administrator.

In the next lab, we'll explore more advanced scripting concepts and real-world automation scenarios.