# Lab 1.3: GitHub Actions CI/CD Pipeline Enhancements

## Overview

In **Lab 1.1** you built a simple workflow that builds and pushes Docker images. That works, but how do you know your code actually works before deploying it?

In this lab, you'll enhance your pipeline with professional-grade quality checks:
- **Automated Testing** - Ensure your code works before building
- **Code Linting** - Catch bugs and enforce best practices
- **Code Formatting** - Maintain consistent style
- **Security Scanning** - Detect vulnerabilities early
- **Coverage Reports** - See what code is tested
- **Artifacts** - Save reports for review

This transforms your basic pipeline into a production-ready CI/CD system.

---

## Prerequisites

- Completed **Lab 1.1: Simple GitHub Actions Docker Build**
- Existing FastAPI application with Docker workflow
- Docker Hub account configured
- GitHub repository with working workflow

---

## What You're Adding

**Before (Lab 1.1):**
```
Push code → Build Docker image → Push to Docker Hub
```

**After (This Lab):**
```
Push code → Run tests → Lint code → Check formatting → Scan for security issues
          ↓
     All passed? → Build Docker image → Scan image → Push to Docker Hub
```

---

## Part 1: Enhance Your FastAPI Application (20 minutes)

You already have a basic FastAPI app from Lab 1.1. Now let's make it more robust by adding a proper structure with tests.

### 1.1 Update Application Structure

Your repository should now look like this:

```
fastapi-docker-{your-initials}/
├── app/
│   ├── __init__.py          # NEW
│   └── main.py             # Update this
├── tests/                   # NEW
│   ├── __init__.py
│   └── test_main.py
├── .github/
│   └── workflows/
│       └── docker-build.yml  # Will update this
├── requirements.txt         # Update this
├── requirements-dev.txt     # NEW
├── .flake8                  # NEW
├── Dockerfile
└── README.md
```

### 1.2 Create Test Files

**`app/__init__.py`** (empty file):
```python
# Empty file to make app a package
```

**`tests/__init__.py`** (empty file):
```python
# Empty file to make tests a package
```

**`tests/test_main.py`**:
```python
from app.main import app
from fastapi.testclient import TestClient

client = TestClient(app)


def test_read_root():
    """Test root endpoint"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json()["message"] == "Hello from FastAPI!"


def test_health_check():
    """Test health check endpoint"""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "healthy"
```

### 1.3 Update Requirements

**`requirements.txt`** (update):
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
```

**`requirements-dev.txt`** (NEW file):
```
-r requirements.txt
pytest==7.4.3
pytest-cov==4.1.0
httpx==0.25.1
black==23.11.0
flake8==6.1.0
pbr>=5.5.0
bandit==1.7.5
```

### 1.4 Create Flake8 Configuration

**`.flake8`** (NEW file):
```ini
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude = 
    .git,
    __pycache__,
    venv,
    .venv
```

### 1.5 Update Python Code for Black Compliance

**`app/main.py`** (update formatting):
```python
import uvicorn
from fastapi import FastAPI

app = FastAPI(title="Simple API", version="1.0.0")


@app.get("/")
def read_root():
    return {"message": "Hello from FastAPI!", "version": "1.0.0"}


@app.get("/health")
def health_check():
    return {"status": "healthy"}


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 1.6 Test Locally

```bash
# Install dev dependencies
pip install -r requirements-dev.txt

# Run tests
pytest tests/ -v

# Run linting
flake8 app/ tests/

# Check formatting
black --check app/ tests/

# Run security scan
bandit -r app/ || true

# If black complains, auto-format:
black app/ tests/
```

---

## Part 2: Enhance GitHub Actions Workflow (20 minutes)

Now let's update your workflow to add quality checks BEFORE building the Docker image.

### 2.1 Update Workflow File

Replace your **`.github/workflows/docker-build.yml`** with this enhanced version:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  security-events: write  # Required for uploading security scan results
  id-token: write  # Required if using OIDC for AWS

env:
  PYTHON_VERSION: '3.11'
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/fastapi-simple

jobs:
  # Job 1: Test and Quality Checks
  test:
    name: Test and Code Quality
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
      
      - name: Lint with flake8
        run: |
          flake8 app/ tests/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 app/ tests/ --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics
      
      - name: Check formatting with black
        run: |
          black --check app/ tests/
      
      - name: Security scan with bandit
        run: |
          bandit -r app/ -f json -o bandit-report.json || true
        continue-on-error: true
      
      - name: Upload bandit report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: bandit-security-report
          path: bandit-report.json
      
      - name: Run tests with pytest
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-report=html
      
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: htmlcov/

  # Job 2: Build and Push Docker Image
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test  # Only run if tests pass!
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE_NAME }}:latest
            ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      # Optional: Scan Docker image for vulnerabilities
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_IMAGE_NAME }}:latest
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true  # Don't fail build on vulnerabilities
      
      # Optional: Upload scan results to GitHub Security tab
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true  # Don't fail if upload doesn't work
```

**Key Changes:**
1. **Two jobs** instead of one (`test` + `build-and-push`)
2. **`needs: test`** - Build only runs if tests pass
3. **Pull request trigger** - Tests run on PRs too
4. **Artifacts** - Save reports for review
5. **Coverage** - See what code is tested

---

## Part 3: Commit and Test the Enhanced Pipeline (15 minutes)

### 3.1 Commit Your Changes

```bash
# Add all new files
git add .

# Commit
git commit -m "Add testing, linting, and quality checks to pipeline"

# Push to main
git push origin main
```

### 3.2 Monitor the Enhanced Pipeline

1. Go to your GitHub repository
2. Click **Actions** tab
3. Watch the workflow execute with TWO jobs:
   - **Job 1: test** - Runs linting, formatting, security, and tests
   - **Job 2: build-and-push** - Only runs if tests pass!

**What You'll See:**
- Code checkout
- Python environment setup  
- Dependencies installed
- Linting passes (flake8)
- Formatting check passes (black)
- Security scan completes (bandit)
- Tests run with coverage (pytest)
- Coverage report uploaded as artifact
- Docker image builds (only on main branch)
- Image pushed to Docker Hub
- Image scanned for vulnerabilities (Trivy)

---

## Part 4: Review Artifacts and Reports (10 minutes)

### 4.1 Download Artifacts

1. **In GitHub Actions:**
   - Go to the completed workflow run
   - Scroll to the bottom to see **Artifacts**
   - Download `bandit-security-report` to review security findings
   - Download `coverage-report` to see test coverage HTML report

2. **View Docker Image Vulnerabilities:**
   - Go to your repository's **Security** tab (top navigation)
   - Click **Code scanning** in the left sidebar
   - Look for alerts from "Trivy" - these show vulnerabilities in your Docker image dependencies
   - Click on any alert to see details: severity, affected package, and how to fix it
   
   **Note:** If you don't see any alerts, that's good news - no vulnerabilities detected! 
   If the Security tab shows "Code scanning is not enabled," the Trivy upload may have failed (common with private repos without GitHub Advanced Security).

### 4.2 Review Coverage Report

1. Extract the downloaded `coverage-report.zip`
2. Open `index.html` in your browser
3. See which lines of code are tested (green) vs not tested (red)
4. Aim for 80%+ coverage in production systems

---

## Part 5: Test Pull Request Quality Gates (15 minutes)

### 5.1 Create a Pull Request with Issues

Let's intentionally introduce issues to see the CI pipeline catch them:

1. Create a new branch:
   ```bash
   git checkout -b test-ci-failures
   ```

2. Introduce a formatting issue in `app/main.py`:
   ```python
   # Add this poorly formatted function at the end of the file
   def poorly_formatted_function(x,y,z):
       result=x+y+z
       return result
   ```

3. Introduce a linting issue:
   ```python
   # Add unused import at the top of app/main.py
   import os
   import sys
   ```

4. Commit and push:
   ```bash
   git add app/main.py
   git commit -m "Test CI pipeline with intentional issues"
   git push origin test-ci-failures
   ```

5. Create a Pull Request on GitHub

6. Watch the CI pipeline run and **FAIL** on the PR

7. Review the errors in the Actions tab

### 5.2 Fix the Issues

1. Remove the poorly formatted function and unused imports

2. Run locally to verify:
   ```bash
   black app/ tests/
   flake8 app/ tests/
   pytest
   ```

3. Commit and push the fixes:
   ```bash
   git add .
   git commit -m "Fix linting and formatting issues"
   git push origin test-ci-failures
   ```

4. Watch the CI pipeline **PASS** on the updated PR

5. Merge the PR if everything passes

---

## Understanding the Enhanced CI/CD Pipeline

### What Happens on Every Push/PR? (Continuous Integration)

1. **Code Quality Checks:**
   - Linting ensures code follows Python best practices
   - Formatting check enforces consistent code style
   - Security scanning detects potential vulnerabilities

2. **Automated Testing:**
   - All tests run automatically
   - Coverage report shows how much code is tested
   - Failures prevent bad code from being merged

3. **Fast Feedback:**
   - Developers know within minutes if their code has issues
   - Issues are caught before code review
   - Reduces time spent on manual code quality checks

### What Happens on Push to Main? (Continuous Delivery)

4. **Build Artifact:**
   - Docker image is built automatically
   - Image is tagged with commit SHA and `latest`
   - Ensures the code can be packaged successfully

5. **Publish to Registry:**
   - Image is pushed to Docker Hub
   - Available for deployment anywhere
   - Versioned and ready to use

6. **Security Validation:**
   - Container image is scanned for vulnerabilities
   - Results are uploaded to GitHub Security tab
   - Security team can review before deployment

### The Result: Continuous Delivery

- **Always Deployable:** The `latest` tag always contains working, tested code
- **Manual Deployment:** You can deploy to production when ready
- **Rollback Ready:** Previous image versions are available in Docker Hub
- **Audit Trail:** GitHub Actions provides a complete history of builds

---

## Success Criteria

You have successfully completed this lab when:

- [ ] FastAPI application runs locally
- [ ] All tests pass locally and in CI
- [ ] Linting and formatting checks pass
- [ ] Security scan completes without critical issues
- [ ] Docker image builds successfully
- [ ] Image is pushed to Docker Hub
- [ ] You can pull and run the image from Docker Hub
- [ ] CI pipeline fails when you introduce intentional errors
- [ ] CI pipeline passes when errors are fixed
- [ ] You understand the difference between CI and CD

---

## Troubleshooting

### Common Issues:

**1. Docker Hub Authentication Failed:**
- Verify secrets are correctly named (`DOCKER_USERNAME` and `DOCKER_PASSWORD`)
- Ensure access token has push permissions
- Check for typos in secret values

**2. Tests Fail in CI but Pass Locally:**
- Check Python version matches between local and CI
- Ensure all dependencies are in `requirements-dev.txt`
- Review GitHub Actions logs for specific errors

**3. Black Formatting Fails:**
- Run `black app/ tests/` locally to auto-format
- Commit the formatted code

**4. Flake8 Errors:**
- Review `.flake8` configuration
- Run `flake8 app/ tests/` locally
- Fix reported issues

**5. Docker Build Fails:**
- Test Docker build locally: `docker build -t test .`
- Check Dockerfile syntax
- Ensure all required files are present

---

## Next Steps

Now that you have a working CI/CD pipeline, consider:

1. **Add More Tests:** Increase test coverage to 90%+
2. **Add Integration Tests:** Test with a real database
3. **Matrix Testing:** Test against multiple Python versions
4. **Deployment Stage:** Add automatic deployment to a staging environment
5. **Notifications:** Send Slack/email notifications on build failures
6. **Code Quality Gates:** Fail builds if coverage drops below threshold
7. **Performance Testing:** Add load testing to the pipeline

---

## Additional Resources

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Python Testing with pytest](https://docs.pytest.org/)
- [Twelve-Factor App Methodology](https://12factor.net/)

---

**Congratulations!** You've built a production-ready CI/CD pipeline that automatically tests, builds, and delivers your application. This is the foundation of modern DevOps practices.
