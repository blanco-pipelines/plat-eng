# Lab 5.1: Blue/Green Deployments with Argo Rollouts

## Overview

You've deployed applications with Argo CD using rolling updates. Now you'll learn blue/green deployments - a strategy that deploys a new version alongside the old one, then switches traffic instantly.

**In this lab:**
- Install Argo Rollouts controller
- Convert your Deployment to a Rollout resource
- Perform a blue/green deployment
- Test the preview environment before promotion
- Switch traffic with zero downtime

**Why Blue/Green?**
- Test new version in production environment before switching traffic
- Instant rollback (just switch back to old version)
- Zero downtime cutover
- Useful for major releases or risky changes

---

## Prerequisites

- Completed Lab 4.2 (GitOps with Argo CD)
- EKS cluster running with Argo CD installed
- `example-application` deployed and healthy

---

## Part 1: Install Argo Rollouts (15 minutes)

### Overview

Argo Rollouts is a separate controller that extends Kubernetes with advanced deployment strategies like blue/green and canary.

### Step 1: Install Argo Rollouts Controller

```bash
kubectl create namespace argo-rollouts
kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml
```

### Step 2: Verify Installation

```bash
kubectl get pods -n argo-rollouts

# Expected output:
# NAME                             READY   STATUS    RESTARTS   AGE
# argo-rollouts-xxxxxxxxxx-xxxxx   1/1     Running   0          30s
```

### Step 3: Install kubectl Plugin (Optional but Recommended)

This gives you helpful commands to manage rollouts:

```bash
# Download the plugin
curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64

# Make it executable
chmod +x kubectl-argo-rollouts-linux-amd64

# Move to PATH
sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

# Verify
kubectl argo rollouts version
```

---

## Part 2: Convert Deployment to Rollout (20 minutes)

### Overview

You'll modify your `example-application` to use a Rollout resource instead of a standard Deployment.

### Step 1: Update Your Repository

In your `example-environment` repository, navigate to:
```
applications/example-application/
```

### Step 2: Create Blue/Green Rollout Manifest

Replace `deployment.yaml` with the following content:

**`rollout.yaml`:**
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: example-application
spec:
  replicas: 2
  revisionHistoryLimit: 2
  selector:
    matchLabels:
      app: example-application
  template:
    metadata:
      labels:
        app: example-application
    spec:
      containers:
      - name: example-application
        image: docker.io/YOUR_USERNAME/example-application:v1.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
  strategy:
    blueGreen:
      activeService: example-application
      previewService: example-application-preview
      autoPromotionEnabled: false
      scaleDownDelaySeconds: 30
---
apiVersion: v1
kind: Service
metadata:
  name: example-application
spec:
  type: LoadBalancer
  selector:
    app: example-application
  ports:
  - port: 8080
    targetPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: example-application-preview
spec:
  type: LoadBalancer
  selector:
    app: example-application
  ports:
  - port: 8080
    targetPort: 8080
```

**Key Changes:**
- `kind: Rollout` instead of `Deployment`
- `strategy.blueGreen` defines the deployment strategy
- `activeService` - receives production traffic
- `previewService` - receives traffic to the new (green) version
- `autoPromotionEnabled: false` - requires manual promotion

**Important:** Replace `YOUR_USERNAME` with your Docker Hub username!

### Step 3: Commit Changes

Delete `deployment.yaml` and create `rollout.yaml` with the content above in your `example-environment` repository. Commit the changes to the `main` branch.

### Step 4: Wait for Argo CD to Sync

```bash
# Watch the sync
kubectl get rollout -n default -w
```

Or check in Argo CD UI - you should see the Rollout resource.

### Step 5: Verify Blue/Green Setup

```bash
# Check rollout status
kubectl argo rollouts get rollout example-application

# Get service endpoints
kubectl get svc example-application
kubectl get svc example-application-preview
```

Both services should have LoadBalancer IPs. The active service points to your current version (blue).

---

## Part 3: Perform Blue/Green Deployment (30 minutes)

### Overview

Now you'll deploy a new version of your application using blue/green strategy.

### Step 1: Update Workflow for Rollouts

Before making code changes, update your `example-environment` repository workflow to work with rollout.yaml:

1. Go to `.github/workflows/update-manifest.yml`
2. Change the sed command from `deployment.yaml` to `rollout.yaml`

### Step 2: Update Your Application

In your `example-application` repository, modify `main.py`.

**Note:** If you completed Lab 4.3 (version injection), you can just tag and release without changing the code - the version will be injected automatically. If you didn't do that lab, use the code below:

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello Argo CD v3.0 - Blue/Green Deployment!'

app.run(host='0.0.0.0', port=8080)
```

### Step 3: Commit and Tag

```bash
git add main.py
git commit -m "Version 3.0 - Blue/Green test"
git tag v3.0.0
git push origin main
git push origin v3.0.0
```

This triggers:
1. GitHub Actions builds `v3.0.0` image
2. GitHub Actions triggers manifest update workflow
3. PR created in `example-environment` repo

### Step 4: Merge the PR

1. Go to your `example-environment` repository on GitHub
2. Review the PR updating the image to `v3.0.0`
3. Merge the PR

### Step 5: Watch the Blue/Green Deployment

```bash
# Watch rollout status
kubectl argo rollouts get rollout example-application --watch
```

**What you'll see:**
- New ReplicaSet created (green version)
- Green pods start alongside blue pods
- Status shows "Paused" waiting for promotion
- Preview service points to green version
- Active service still points to blue version

### Step 6: Test the Preview Environment

Get the preview service URL:

```bash
kubectl get svc example-application-preview -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
```

Test it:
```bash
curl http://<PREVIEW-SERVICE-URL>:8080
# Should return: Hello Argo CD v3.0 - Blue/Green Deployment! or new version
```

Test the active (production) service:
```bash
kubectl get svc example-application -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
curl http://<ACTIVE-SERVICE-URL>:8080
# Should still return: Hello Argo CD v2.0! or old version
```

**This is the power of blue/green** - production still serves old version while you test the new one!

### Step 7: Promote to Production

Once you're satisfied with testing:

```bash
kubectl argo rollouts promote example-application
```

**What happens:**
1. Active service selector switches to green pods
2. Traffic instantly cuts over to v3.0.0
3. Old blue pods remain for 30 seconds (scaleDownDelaySeconds)
4. Blue pods are deleted
5. Green becomes the new blue

### Step 8: Verify Promotion

```bash
# Check rollout status
kubectl argo rollouts get rollout example-application

# Test active service now
curl http://<ACTIVE-SERVICE-URL>:8080
# Should now return: Hello Argo CD v3.0 - Blue/Green Deployment!
```

---

## Part 4: Rollback Scenario (15 minutes)

### Overview

Simulate a bad deployment and perform an instant rollback.

### Step 1: Deploy a "Broken" Version

Update `main.py`:
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'v4.0.0 - BROKEN VERSION!'  # Pretend this is broken

app.run(host='0.0.0.0', port=8080)
```

Tag and push:
```bash
git add main.py
git commit -m "Version 4.0 - broken"
git tag v4.0.0
git push origin main
git push origin v4.0.0
```

Merge the PR in `example-environment` when it's created.

### Step 2: Test in Preview

```bash
curl http://<PREVIEW-SERVICE-URL>:8080
# Returns: v3.0.0 - BROKEN VERSION!
```

You discover this version is broken! Don't promote it.

### Step 3: Abort the Rollout

Instead of promoting, abort:

```bash
kubectl argo rollouts abort example-application
```

This immediately:
- Scales down the green (broken) pods
- Keeps blue (v2.0.0) running in production
- No user impact!

### Step 4: Verify Production Still Running v2.0.0

```bash
curl http://<ACTIVE-SERVICE-URL>:8080
# Still returns: Hello Argo CD v2.0 - Blue/Green Deployment!
```

**Zero downtime, zero user impact!**

---

## Part 5: Discussion - Blue/Green vs Rolling Updates

### When to Use Blue/Green

**Advantages:**
- ‚úÖ Test in production environment before cutover
- ‚úÖ Instant rollback (just switch service back)
- ‚úÖ Zero downtime
- ‚úÖ Good for major releases
- ‚úÖ Easy to understand and visualize

**Disadvantages:**
- ‚ùå Requires 2x resources during deployment (blue + green)
- ‚ùå Database migrations can be tricky
- ‚ùå All traffic switches at once (can be risky for huge services)

### When to Use Rolling Updates

**Advantages:**
- ‚úÖ Gradual rollout (easier to monitor)
- ‚úÖ Less resource usage (no 2x pods)
- ‚úÖ Good for incremental changes

**Disadvantages:**
- ‚ùå Mixed versions during rollout
- ‚ùå Slower to rollback
- ‚ùå Can't test new version separately

### When to Use Canary

**Advantages:**
- ‚úÖ Gradual traffic shift (10% ‚Üí 50% ‚Üí 100%)
- ‚úÖ Detect issues with small percentage of users
- ‚úÖ Good for high-traffic services

**Disadvantages:**
- ‚ùå More complex setup
- ‚ùå Longer deployment time

---

## Part 6: Bonus Challenges (Optional)

### Bonus 1: Automated Promotion

Enable auto-promotion after 2 minutes:

```yaml
strategy:
  blueGreen:
    activeService: example-application
    previewService: example-application-preview
    autoPromotionEnabled: true
    autoPromotionSeconds: 120
```

### Bonus 2: Health Checks

Add liveness and readiness probes to make rollouts more robust. Update your `rollout.yaml`:

```yaml
spec:
  template:
    spec:
      containers:
      - name: example-application
        image: docker.io/danblanco/example-application:v1.0.0
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 3
          periodSeconds: 5
```

Now Argo Rollouts will only mark pods as "Healthy" if they pass HTTP health checks. Without probes, it just checks if the container is running.


---

## Cleanup

### Clean Up Lab Resources

```bash
# Delete the rollout
kubectl delete rollout example-application

# Delete services
kubectl delete svc example-application example-application-preview

# Optional: Uninstall Argo Rollouts
kubectl delete namespace argo-rollouts
```

### Delete the EKS Cluster

**Important:** EKS clusters cost money (~$0.10/hour for control plane + EC2 costs). Delete your cluster when you're done with all Kubernetes labs.

```bash
eksctl delete cluster --name gitops-demo --region us-west-2
```

This command will:
- Delete all node groups
- Delete the control plane
- Clean up associated VPC resources
- Remove load balancers and volumes

**This takes ~10-15 minutes to complete.**

**Verify deletion:**
```bash
eksctl get cluster --region us-west-2
# Should show no clusters
```

**Cost reminder:** Make sure to verify in the AWS Console that:
- EC2 instances are terminated
- Load Balancers are deleted
- EBS volumes are removed
- VPC resources are cleaned up


```bash
# Delete the leftover CloudFormation stacks
aws cloudformation delete-stack \
  --region us-west-2 \
  --stack-name eksctl-gitops-demo-cluster

# Wait for deletion to complete (may take 5-10 minutes)
aws cloudformation wait stack-delete-complete \
  --region us-west-2 \
  --stack-name eksctl-gitops-demo-cluster

# Also delete the nodegroup stack if it exists
aws cloudformation delete-stack \
  --region us-west-2 \
  --stack-name eksctl-gitops-demo-nodegroup-ng-1
```

**Or via AWS Console:**
1. Go to CloudFormation
2. Find stacks starting with "eksctl-gitops-demo"
3. Delete them manually

---

## Success Criteria

- [ ] Installed Argo Rollouts controller
- [ ] Converted Deployment to Rollout resource
- [ ] Deployed new version using blue/green strategy
- [ ] Tested preview environment before promotion
- [ ] Successfully promoted to production
- [ ] Performed rollback/abort scenario
- [ ] Understand when to use blue/green vs rolling updates

---

## Key Takeaways

**Blue/Green Deployments:**
- Deploy new version alongside old version
- Test in production environment before cutover
- Instant traffic switch with zero downtime
- Easy rollback (just switch back)

**Argo Rollouts:**
- Extends Kubernetes with advanced deployment strategies
- Works seamlessly with Argo CD
- Supports blue/green, canary, and progressive delivery
- Powerful CLI and dashboard

**Real-World Use Cases:**
- Major version upgrades
- Database schema changes (test with blue, promote when ready)
- High-stakes releases requiring validation
- Services where gradual rollout isn't appropriate

**Trade-offs:**
- Requires 2x resources during deployment
- Best for stateless applications
- Database migrations require careful planning

**Next Steps:**
In production, you'd combine this with:
- Automated testing in preview environment
- Metrics-based promotion (success rate, latency)
- Slack/PagerDuty notifications
- Audit logs for compliance

---

**Congratulations!** You've mastered blue/green deployments with Argo Rollouts! üéâ
