# Lab 3.3: Terraform Infrastructure with Custom AMI

## Overview

In Lab 2.2, you built a golden AMI with Docker and your FastAPI application baked in. Now it's time to use it!

In this lab, you'll **modify your Lab 2.1 Terraform code** to use your custom AMI instead of user data. The changes are minimal - just swap the AMI data source, remove user data, and add instance refresh configuration.

**What You'll Change:**
- AMI data source ‚Üí find your custom AMI instead of Amazon Linux
- Launch template ‚Üí use custom AMI, remove user data
- ASG configuration ‚Üí add instance refresh for rolling deployments
- Outputs ‚Üí show which AMI is being used

**The Result:**
- Lab 2.1: Instances configure on boot (~5 min) ‚ùå
- Lab 2.3: Instances boot ready (~1 min) ‚úÖ

---

## Prerequisites

- Completed Lab 2.1 (Terraform Infrastructure) - **Code required**
- Completed Lab 2.2 (Packer Golden AMI) - **AMI must exist**
- Completed Lab 1.4 (GitHub OIDC Setup)
- Lab 2.1 infrastructure **destroyed** (`terraform destroy`)
- AWS credentials configured locally

---

## Architecture Overview

```
Same infrastructure as Lab 2.1, but:

Data Source Change:
  Amazon Linux AMI ‚Üí Your Custom Golden AMI
  
Launch Template Change:
  - User data script (3-5 min boot)
  + Pre-configured AMI (~1 min boot)
  
ASG Addition:
  + Instance refresh configuration
  + Faster health check grace period
```

**Key Differences:**
- **No user data** - everything baked into AMI
- **Faster boot** - instances ready in ~1 minute
- **Immutable** - all instances identical
- **Versioned** - automatic rollback capability

---

## Part 1: Prepare Your Terraform Code (5 minutes)

### 1.1 Option A: Use Existing Lab 2.1 Code

If you still have your Lab 2.1 code locally:

```bash
# Copy the entire directory
cp -r fastapi-terraform-infra-{your-initials} fastapi-terraform-custom-ami-{your-initials}
cd fastapi-terraform-custom-ami-{your-initials}

# Clean Terraform state
rm -rf terraform/.terraform* terraform/terraform.tfstate*
```

### 1.2 Option B: Clone from GitHub

If your Lab 2.1 code is only on GitHub:

```bash
git clone https://github.com/your-username/fastapi-terraform-infra-{your-initials}.git fastapi-terraform-custom-ami-{your-initials}
cd fastapi-terraform-custom-ami-{your-initials}

# Clean Terraform state
rm -rf terraform/.terraform* terraform/terraform.tfstate*
```

### 1.3 Create New GitHub Repository

1. Go to GitHub and create a new repository:
   - **Name:** `fastapi-terraform-custom-ami-{your-initials}`
   - **Description:** "Terraform IaC using custom golden AMIs"
   - **Public** or **Private**
   - **DO NOT** initialize with README

2. Update remote:
   ```bash
   git remote set-url origin https://github.com/your-username/fastapi-terraform-custom-ami-{your-initials}.git
   git push -u origin main
   ```

---

## Part 2: Modify Compute Module to Use Custom AMI (10 minutes)

You only need to modify `terraform/modules/compute/main.tf` and `terraform/modules/compute/outputs.tf`.

### 2.1 Update AMI Data Source

**In `terraform/modules/compute/main.tf`, replace `data "aws_ami" "amazon_linux_2023"` with:**

```hcl
# Data source to find latest custom AMI built by Packer
data "aws_ami" "fastapi_golden" {
  most_recent = true
  owners      = ["self"]  # AMIs you own

  filter {
    name   = "name"
    values = ["fastapi-golden-ami-${var.environment}-*"]
  }

  filter {
    name   = "tag:Environment"
    values = [var.environment]
  }

  filter {
    name   = "tag:ManagedBy"
    values = ["Packer"]
  }

  filter {
    name   = "state"
    values = ["available"]
  }
}
```

### 2.2 Update Launch Template

**In `terraform/modules/compute/main.tf`, replace `resource "aws_launch_template" "main"` with:**

```hcl
# Launch Template - Uses Custom AMI!
resource "aws_launch_template" "main" {
  name_prefix   = "${var.project_name}-${var.environment}-"
  image_id      = data.aws_ami.fastapi_golden.id  # Custom AMI!
  instance_type = var.instance_type

  iam_instance_profile {
    name = aws_iam_instance_profile.ec2_profile.name
  }

  vpc_security_group_ids = [aws_security_group.ec2.id]

  # NO USER DATA NEEDED! Everything is in the AMI!

  metadata_options {
    http_endpoint               = "enabled"
    http_tokens                 = "required"
    http_put_response_hop_limit = 1
  }

  monitoring {
    enabled = true
  }

  tag_specifications {
    resource_type = "instance"
    tags = merge(
      var.tags,
      {
        Name        = "${var.project_name}-${var.environment}-instance"
        Environment = var.environment
        ManagedBy   = "Terraform"
        AMI_ID      = data.aws_ami.fastapi_golden.id
        AMI_Name    = data.aws_ami.fastapi_golden.name
      }
    )
  }

  tags = var.tags
}
```

**Key changes:**
- `image_id = data.aws_ami.fastapi_golden.id`
- **Removed entire `user_data` block**
- Added AMI_ID and AMI_Name tags

### 2.3 Update Auto Scaling Group

**In `terraform/modules/compute/main.tf`, replace `resource "aws_autoscaling_group" "main"` with:**

```hcl
# Auto Scaling Group
resource "aws_autoscaling_group" "main" {
  name                = "${var.project_name}-${var.environment}-asg"
  vpc_zone_identifier = var.subnet_ids
  target_group_arns   = [aws_lb_target_group.main.arn]
  health_check_type   = "ELB"
  health_check_grace_period = var.health_check_grace_period

  desired_capacity = var.desired_capacity
  min_size         = var.min_size
  max_size         = var.max_size

  launch_template {
    id      = aws_launch_template.main.id
    version = "$Latest"
  }

  # Instance refresh for zero-downtime deployments
  instance_refresh {
    strategy = "Rolling"
    preferences {
      min_healthy_percentage = 50
      instance_warmup        = 60
    }
  }

  tag {
    key                 = "Name"
    value               = "${var.project_name}-${var.environment}-asg-instance"
    propagate_at_launch = true
  }

  tag {
    key                 = "Environment"
    value               = var.environment
    propagate_at_launch = true
  }

  tag {
    key                 = "ManagedBy"
    value               = "Terraform"
    propagate_at_launch = true
  }

  lifecycle {
    create_before_destroy = true
  }
}
```

**Key change:**
- Added `instance_refresh` block for rolling deployments

### 2.4 Add AMI Outputs

**Add to `terraform/modules/compute/outputs.tf`:**

```hcl
output "ami_id" {
  description = "AMI ID being used by the launch template"
  value       = data.aws_ami.fastapi_golden.id
}

output "ami_name" {
  description = "AMI name being used"
  value       = data.aws_ami.fastapi_golden.name
}
```

---

## Part 3: Update Root Module Outputs (2 minutes)

**Add to `terraform/outputs.tf`:**

```hcl
output "ami_id" {
  description = "AMI ID being used"
  value       = module.compute.ami_id
}

output "ami_name" {
  description = "AMI name being used"
  value       = module.compute.ami_name
}
```

---

## Part 4: Summary of Changes

Here's everything you modified from Lab 2.1:

| File | Changes |
|------|---------|
| `modules/compute/main.tf` | ‚Ä¢ AMI data source: `amazon_linux_2023` ‚Üí `fastapi_golden`<br>‚Ä¢ Launch template: Removed `user_data`, changed `image_id`<br>‚Ä¢ ASG: Added `instance_refresh` block |
| `modules/compute/outputs.tf` | ‚Ä¢ Added `ami_id` and `ami_name` outputs |
| `terraform/outputs.tf` | ‚Ä¢ Added `ami_id` and `ami_name` outputs |

**Everything else stays the same!**

---

---

## Part 5: Deploy Infrastructure (10 minutes)

### 5.1 Initialize and Verify

```bash
cd terraform
terraform init

# Verify AMI will be found
terraform plan
# Look for: data.aws_ami.fastapi_golden: Read complete [id=ami-xxxxx]
```

**If AMI not found:**
- Run: `aws ec2 describe-images --owners self --filters "Name=name,Values=fastapi-golden-ami-dev-*"`

### 5.2 Deploy

```bash
terraform apply
```

### 5.3 Test Application

```bash
# Get ALB URL and test
ALB_URL=$(terraform output -raw alb_url)
sleep 30
curl $ALB_URL
```

Visit the URL in your browser!

---

## Part 6: Test Auto Scaling (Optional, 5 minutes)

### Test Instance Replacement

```bash
# Terminate an instance
INSTANCE_ID=$(aws autoscaling describe-auto-scaling-groups \
  --auto-scaling-group-names $(terraform output -raw asg_name) \
  --query 'AutoScalingGroups[0].Instances[0].InstanceId' \
  --output text)

aws ec2 terminate-instances --instance-ids $INSTANCE_ID
```

Watch in the AWS Console - ASG launches a replacement that boots in ~1 minute!

---

## Part 7: Understanding What You Built

### Key Differences from Lab 2.1

| Aspect | Lab 3.1 (User Data) | Lab 3.3 (Custom AMI) |
|--------|---------------------|----------------------|
| Configuration | User data script | Baked into AMI |
| Boot time | ~5-6 minutes | ~1 minute |
| Consistency | Varies | 100% identical |
| Updates | Modify user data | Build new AMI |
| Scalability | Slow | Fast |

### Why This Matters

**AMI Data Source:**
```hcl
data "aws_ami" "fastapi_golden" {
  most_recent = true  # Auto-finds newest AMI!
}
```
- No hardcoded AMI IDs
- Automatically uses latest AMI on `terraform apply`
- Just build new AMI and re-deploy!

**Instance Refresh:**
```hcl
instance_refresh {
  strategy = "Rolling"
  preferences {
    min_healthy_percentage = 50
  }
}
```
- Enables zero-downtime deployments when AMI changes
- Lab 2.4 will show this in action!

---

## Success Criteria

- [ ] Modified 3 resources in compute module
- [ ] Added AMI outputs
- [ ] Infrastructure deploys using custom AMI
- [ ] Instances boot in ~1 minute (vs 5-6 min)
- [ ] Application accessible via ALB

---

## Cleanup

**Keep running for Lab 2.4!**

```bash
# If you need to destroy:
terraform destroy
```

---

## Quick Reference

**Files Modified:**
- `modules/compute/main.tf` - AMI data source, launch template, ASG
- `modules/compute/outputs.tf` - Added ami_id, ami_name
- `terraform/outputs.tf` - Added ami_id, ami_name

**Next Lab:** Zero-downtime rolling deployments!

---

## Troubleshooting

**"No AMIs found" error:**
```bash
# Verify AMI exists
aws ec2 describe-images --owners self \
  --filters "Name=name,Values=fastapi-golden-ami-dev-*" \
  --query 'Images[*].[ImageId,Name,CreationDate]' \
  --output table

# Check environment tag
aws ec2 describe-images --owners self \
  --filters "Name=tag:Environment,Values=dev" \
  --query 'Images[*].[ImageId,Name]' --output table
```

**Wrong AMI being used:**
```bash
# Force data source refresh
terraform refresh

# Verify which AMI Terraform sees
terraform console
> data.aws_ami.fastapi_golden.id
> data.aws_ami.fastapi_golden.name
```

---

## Key Takeaways

**What You Learned:**
- Using Terraform data sources to find resources
- Deploying infrastructure with custom AMIs
- Immutable infrastructure patterns
- Fast instance boot times
- Instance refresh for rolling deployments

**Why This Matters:**
- **Production-ready:** This is how Netflix, Airbnb, etc. deploy
- **Fast scaling:** Handle traffic spikes instantly
- **Reliable:** Every instance boots identically
- **Safe updates:** Test new AMI, then rolling deploy
- **Easy rollback:** Switch back to previous AMI

**Next Lab:** You'll update your application, build a new AMI, and perform a zero-downtime rolling deployment to the running infrastructure!

---

## Additional Resources

- [Terraform aws_ami Data Source](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami)
- [AWS Auto Scaling Instance Refresh](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html)
- [Immutable Infrastructure](https://www.hashicorp.com/resources/what-is-mutable-vs-immutable-infrastructure)

---

**Congratulations!** You're running production-grade immutable infrastructure! üéâ
