# Lab 2.3: Ansible Configuration Management

## Overview

In Lab 1.2, you manually deployed your FastAPI application to EC2 by SSH-ing into the instance and running Docker commands. That works for one server, but what if you need to deploy to multiple servers? Or repeat the deployment consistently?

**Ansible** is a configuration management tool that automates server setup and application deployment. Instead of manually typing commands, you write "playbooks" that describe the desired state, and Ansible makes it happen.

In this lab, you'll use Ansible to automate the same deployment you did manually in Lab 1.1. You'll run Ansible from your local machine to configure an EC2 instance.

**What You'll Learn:**
- Ansible playbooks and tasks
- Ansible inventory management
- Using Ansible to install Docker
- Deploying Docker containers with Ansible
- Ansible idempotency (safe to run multiple times)

---

## Prerequisites

- Completed Lab 1.1 (Docker image on Docker Hub)
- Completed Lab 1.2 (Manual deployment) - or at least have an EC2 instance running
- EC2 instance with SSH access
- SSH key pair (`.pem` file)
- Ansible installed on your local machine

---

## Architecture

```
Your Local Machine
        |
        | (SSH connection)
        v
EC2 Instance
        |
        v
Ansible playbook executes:
  1. Update system packages
  2. Install Docker
  3. Add ec2-user to docker group
  4. Start Docker service
  5. Pull Docker image from Docker Hub
  6. Run container on port 80
```

---

## Part 1: Install Ansible Locally (5 minutes)

### 1.1 Install Ansible


**Linux (dnf):**
```bash
sudo dnf update
sudo dnf install ansible -y
```

### 1.2 Verify Installation

```bash
ansible --version

# Should see something like:
# ansible [core 2.15.x]
```

---

## Part 2: Create Ansible Project Structure (10 minutes)

### 2.1 Create Project Directory

```bash
mkdir fastapi-ansible-deployment
cd fastapi-ansible-deployment
```

### 2.2 Create Directory Structure

```bash
mkdir -p roles/docker_app/{tasks,handlers}
touch inventory.ini
touch playbook.yml
touch ansible.cfg
touch roles/docker_app/tasks/main.yml
touch roles/docker_app/handlers/main.yml
```

**Your structure:**
```
fastapi-ansible-deployment/
â”œâ”€â”€ ansible.cfg
â”œâ”€â”€ inventory.ini
â”œâ”€â”€ playbook.yml
â””â”€â”€ roles/
    â””â”€â”€ docker_app/
        â”œâ”€â”€ tasks/
        â”‚   â””â”€â”€ main.yml
        â””â”€â”€ handlers/
            â””â”€â”€ main.yml
```

### 2.3 Create Ansible Configuration

**`ansible.cfg`:**
```ini
[defaults]
host_key_checking = False
inventory = inventory.ini
remote_user = ec2-user
private_key_file = ~/.ssh/your-key.pem

[privilege_escalation]
become = True
become_method = sudo
become_user = root
```

**Replace `~/.ssh/your-key.pem`** with the actual path to your SSH key!

---

## Part 3: Configure Inventory (5 minutes)

### 3.1 Get EC2 Public IP

1. Go to AWS Console â†’ EC2 â†’ Instances
2. Find your instance from Lab 1.1
3. Copy the **Public IPv4 address**

### 3.2 Create Inventory File

**`inventory.ini`:**
```ini
[webservers]
fastapi-server ansible_host=YOUR_EC2_PUBLIC_IP

[webservers:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=~/.ssh/your-key.pem
```

**Replace:**
- `YOUR_EC2_PUBLIC_IP` with your actual EC2 public IP
- `~/.ssh/your-key.pem` with your SSH key path

### 3.3 Test Connection

```bash
ansible webservers -m ping
```

**Expected output:**
```
fastapi-server | SUCCESS => {
    "changed": false,
    "ping": "pong"
}
```

**If it fails:**
- Check EC2 security group allows SSH from your IP
- Verify SSH key path is correct
- Ensure EC2 instance is running
- **Fix SSH key permissions if too open:** If you get "WARNING: UNPROTECTED PRIVATE KEY FILE" or "Permissions 0644 are too open", run:
  ```bash
  chmod 600 /path/to/your-key.pem
  ```

---

## Part 4: Create Ansible Role for Docker App (20 minutes)

### 4.1 Define Tasks

**`roles/docker_app/tasks/main.yml`:**
```yaml
---
# Install Docker and deploy FastAPI application

- name: Update all packages
  dnf:
    name: "*"
    state: latest
    update_cache: yes

- name: Install Docker
  dnf:
    name: docker
    state: present

- name: Reload systemd daemon
  systemd:
    daemon_reload: yes

- name: Start and enable Docker service
  systemd:
    name: docker
    state: started
    enabled: yes

- name: Add ec2-user to docker group
  user:
    name: ec2-user
    groups: docker
    append: yes
  notify: Restart Docker

- name: Pull Docker image from Docker Hub
  community.docker.docker_image:
    name: "{{ docker_image }}"
    source: pull
    force_source: yes

- name: Stop existing container (if any)
  community.docker.docker_container:
    name: fastapi-app
    state: absent
  ignore_errors: yes

- name: Run FastAPI container
  community.docker.docker_container:
    name: fastapi-app
    image: "{{ docker_image }}"
    state: started
    restart_policy: always
    published_ports:
      - "80:8000"
    pull: yes
```

### 4.2 Define Handlers

**`roles/docker_app/handlers/main.yml`:**
```yaml
---
- name: Restart Docker
  systemd:
    name: docker
    state: restarted
```

---

## Part 5: Create Main Playbook (5 minutes)

### 5.1 Create Playbook

**`playbook.yml`:**
```yaml
---
- name: Deploy FastAPI Application with Docker
  hosts: webservers
  become: yes
  
  vars:
    docker_image: "YOUR_DOCKERHUB_USERNAME/fastapi-cicd:latest"
  
  roles:
    - docker_app
  
  post_tasks:
    - name: Wait for application to start
      wait_for:
        port: 80
        delay: 5
        timeout: 60
      
    - name: Test application endpoint
      uri:
        url: "http://localhost/"
        status_code: 200
      register: app_response
    
    - name: Display application response
      debug:
        msg: "Application is running! Response: {{ app_response }}"
```

**Replace `YOUR_DOCKERHUB_USERNAME`** with your Docker Hub username!

---

## Part 6: Install Ansible Docker Collection (5 minutes)

The `community.docker` collection provides Docker modules for Ansible.

### 6.1 Install Collection

```bash
ansible-galaxy collection install community.docker
```

### 6.2 Verify Installation

```bash
ansible-galaxy collection list | grep docker
```

---

## Part 7: Run the Ansible Playbook (10 minutes)

### 7.1 Check What Will Change (Dry Run)

```bash
ansible-playbook playbook.yml --check
```

This shows what Ansible *would* do without making changes.

**Note:** Check mode may show failures for service starts because packages aren't actually installed in dry-run mode. This is normal - the actual run will work fine.

### 7.2 Execute Playbook

```bash
ansible-playbook playbook.yml
```

### 7.3 Verify Deployment

```bash
# Get your EC2 public IP
EC2_IP="YOUR_EC2_PUBLIC_IP"

# Test the application
curl http://$EC2_IP/
```

**Expected response:**
```json
{
  "message": "Hello from FastAPI!",
  "version": "1.0.0"
}
```

### 7.4 Verify with Check Mode

Now that everything is deployed, you can use check mode to verify configuration:

```bash
ansible-playbook playbook.yml --check
```

This shows what Ansible would change (should be nothing if deployment succeeded). Check mode is useful after initial deployment to verify idempotency.

---

## Part 8: Test Idempotency (5 minutes)

One of Ansible's key features is **idempotency** - you can run the playbook multiple times safely.

### 8.1 Run Playbook Again

```bash
ansible-playbook playbook.yml
```

**`changed=0`** means Ansible detected everything was already in the desired state and didn't make unnecessary changes!

### 8.2 Force Update (Deploy New Version)

If you pushed a new Docker image, you can force Ansible to pull it:

```bash
ansible-playbook playbook.yml
```

Ansible will pull the latest image and restart the container only if the image changed.

---

## Part 9: Making Changes (10 minutes)

### 9.1 Update the Application Version

Let's test updating the deployment to use a specific version tag. You will have to make sure you have built an image to match the different tag version.

**Edit `playbook.yml`:**
```yaml
vars:
  docker_image: "YOUR_DOCKERHUB_USERNAME/fastapi-cicd:v2.0"
```

### 9.2 Redeploy

```bash
ansible-playbook playbook.yml
```

Ansible will:
1. Pull the new image tag
2. Stop the old container
3. Start a new container with the new image

### 9.3 Verify Update

```bash
curl http://$EC2_IP/
```

---

## Understanding What Ansible Did

### Key Concepts

**1. Idempotency:**
- Safe to run multiple times
- Only makes changes when needed
- `changed` vs `ok` status

**2. Tasks:**
- Individual actions (install package, start service, etc.)
- Run in order
- Can have conditions

**3. Handlers:**
- Run only when notified
- Triggered by changes
- Run at end of playbook

**4. Roles:**
- Organize tasks into reusable components
- Standard directory structure
- Easy to share and reuse

**5. Variables:**
- Make playbooks flexible
- Can be overridden
- Used in templates and tasks

---

## Troubleshooting

**Connection refused:**
```bash
# Check EC2 security group allows SSH from your IP
# Verify EC2 instance is running
# Test SSH manually:
ssh -i ~/.ssh/your-key.pem ec2-user@YOUR_EC2_IP
```

**Permission denied (publickey):**
```bash
# Check SSH key path in ansible.cfg and inventory.ini
# Verify key has correct permissions:
chmod 400 ~/.ssh/your-key.pem
```

**Docker module not found:**
```bash
# Install Docker collection:
ansible-galaxy collection install community.docker
```

**Container fails to start:**
```bash
# SSH to instance and check Docker logs:
ssh -i ~/.ssh/your-key.pem ec2-user@YOUR_EC2_IP
sudo docker logs fastapi-app
```

**Application not accessible:**
```bash
# Check security group allows HTTP (port 80)
# Verify container is running:
ansible webservers -m shell -a "sudo docker ps"
```

---

## Cleanup

### Stop the Application

```bash
ansible webservers -m community.docker.docker_container -a "name=fastapi-app state=stopped" --become
```

### Remove the Container

```bash
ansible webservers -m community.docker.docker_container -a "name=fastapi-app state=absent" --become
```

### Uninstall Docker (Optional)

```bash
ansible webservers -m dnf -a "name=docker state=absent" --become
```

### Terminate EC2 Instance

- Follow cleanup steps from Lab 1.1

---

## Key Takeaways

**What You Learned:**
- Ansible basics: playbooks, tasks, roles, handlers
- Configuration management vs manual deployment
- Idempotent deployments
- Infrastructure as Code (IaC) for configuration
- Ansible inventory and SSH connections

**Manual Deployment (Lab 1.1) vs Ansible (Lab 1.3):**

| Task | Manual | Ansible |
|------|--------|---------|
| Deploy to 1 server | 10 commands | 1 command |
| Deploy to 10 servers | 100 commands | 1 command |
| Consistent config | Manual checking | Guaranteed |
| Repeatable | Copy/paste errors | Idempotent |
| Documented | Notes/wiki | Playbook is docs |

**In the next labs**, you'll:
- Use Terraform to provision infrastructure automatically
- Combine Ansible with GitHub Actions for CI/CD
- Deploy to Auto Scaling Groups with dynamic inventory

---

## Additional Challenges (Optional)

**1. Add health checks:**
```yaml
- name: Verify application health
  uri:
    url: "http://localhost/health"
    status_code: 200
```

**2. Use Ansible Vault for secrets:**
```bash
ansible-vault create secrets.yml
# Store Docker Hub credentials
```

**3. Create multiple environments:**
```ini
[dev]
dev-server ansible_host=IP1

[prod]
prod-server ansible_host=IP2
```

**4. Add logging configuration:**
```yaml
- name: Configure Docker logging
  community.docker.docker_container:
    name: fastapi-app
    log_driver: json-file
    log_options:
      max-size: "10m"
      max-file: "3"
```

---

**Congratulations!** You've automated your first deployment with Ansible! You now understand why configuration management tools are essential for managing infrastructure at scale. ðŸš€
