# Lab 2.2: Manual Deployment to AWS EC2

## Overview

In this lab, you will manually deploy your FastAPI application from Docker Hub to an AWS EC2 instance. This "classic" deployment approach will help you understand the fundamental steps involved in getting an application running in the cloud.

**Why Manual Deployment?**

Before we automate everything, it's important to understand what's actually happening during a deployment. Manual deployment teaches you:
- The actual steps required to run an application in production
- How to troubleshoot deployment issues
- What to automate later
- Appreciation for automation tools!

Later in the course, you'll use automation tools (Ansible, Terraform, CI/CD) to handle all of this automatically. But for now, you'll do it the old-fashioned way - SSH and command line.

---

## Prerequisites

- Completed Lab 1.1 (GitHub Actions CI/CD)
- Docker image pushed to Docker Hub
- AWS account with EC2 access
- Your SSH key pair (or create a new one)

---

## Part 1: Launch an EC2 Instance (10 minutes)

### 1.1 Create EC2 Instance

1. Log in to AWS Console
2. Navigate to **EC2** â†’ **Instances** â†’ **Launch Instance**

3. **Configure the instance:**
   - **Name:** `fastapi-manual-deployment-{your-initials}`
   - **Application and OS Images (AMI):** Amazon Linux 2023 AMI
   - **Instance type:** t2.micro (Free tier eligible)
   - **Key pair:** Select your existing key pair or create a new one
     - If creating new: Download and save the `.pem` file securely
   - **Network settings:**
     - Create security group: `fastapi-manual-sg-{your-initials}`
     - Allow SSH (port 22) from your IP
     - **Add rule:** HTTP (port 80) from Anywhere (0.0.0.0/0)
   - **Storage:** 8 GB gp3 (default is fine)

4. Click **Launch instance**

5. Wait for instance state to show **Running** (2-3 minutes)

6. Note the **Public IPv4 address** - you'll need this

---

## Part 2: SSH into Your Instance (5 minutes)

### 2.1 Connect via SSH

**If you're on Windows (using Git Bash or WSL):**
```bash
# Set correct permissions on your key file
chmod 400 /path/to/your-key.pem

# SSH into the instance
ssh -i /path/to/your-key.pem ec2-user@<your-instance-public-ip>
```

**If you're on Linux/Mac:**
```bash
# Set correct permissions on your key file
chmod 400 /path/to/your-key.pem

# SSH into the instance
ssh -i /path/to/your-key.pem ec2-user@<your-instance-public-ip>
```

**Alternative: Use EC2 Instance Connect (Browser-based):**
1. In AWS Console, select your instance
2. Click **Connect** button
3. Choose **EC2 Instance Connect** tab
4. Click **Connect**

You should now see a command prompt like:
```
[ec2-user@ip-xxx-xxx-xxx-xxx ~]$
```

---

## Part 3: Install Docker on EC2 (10 minutes)

### 3.1 Update System Packages

Amazon Linux 2023 uses `dnf` (the successor to `yum`) as its package manager.

```bash
# Update all packages to latest versions
sudo dnf update -y
```

### 3.2 Install Docker

```bash
# Install Docker
sudo dnf install docker -y
```

### 3.3 Start Docker Service

```bash
# Start the Docker service
sudo systemctl start docker

# Enable Docker to start on boot
sudo systemctl enable docker

# Verify Docker is running
sudo systemctl status docker
```

You should see output showing Docker is **active (running)**.

### 3.4 Add Your User to Docker Group

By default, you need `sudo` to run Docker commands. Let's fix that:

```bash
# Add ec2-user to the docker group
sudo usermod -aG docker ec2-user
```

### 3.5 Refresh Group Membership

For the group change to take effect, you need to log out and log back in:

```bash
# Exit the SSH session
exit
```

Now SSH back in:
```bash
ssh -i /path/to/your-key.pem ec2-user@<your-instance-public-ip>
```

### 3.6 Verify Docker Access

```bash
# Test Docker without sudo
docker --version

# Verify you can run Docker commands
docker ps
```

If you see the Docker version and an empty container list (no errors), you're ready to go!

---

## Part 4: Pull and Run Your Application (10 minutes)

### 4.1 Pull Your Docker Image from Docker Hub

```bash
# Pull your image from Docker Hub
docker pull <your-dockerhub-username>/fastapi-simple:latest
```

**Example:**
```bash
docker pull johndoe/fastapi-simple:latest
```

You'll see Docker downloading the image layers. This might take a minute or two.

### 4.2 Run the Container

Now for the moment of truth - let's run your application!

```bash
# Run the container
# -d: Run in detached mode (background)
# -p 80:8000: Map host port 80 to container port 8000
# --name: Give the container a friendly name
# --restart unless-stopped: Restart container if it crashes
docker run -d \
  -p 80:8000 \
  --name fastapi-app \
  --restart unless-stopped \
  <your-dockerhub-username>/fastapi-simple:latest
```

**Example:**
```bash
docker run -d \
  -p 80:8000 \
  --name fastapi-app \
  --restart unless-stopped \
  johndoe/fastapi-simple:latest
```

### 4.3 Verify the Container is Running

```bash
# List running containers
docker ps

# You should see output like:
# CONTAINER ID   IMAGE                            COMMAND                  STATUS         PORTS
# abc123def456   johndoe/fastapi-simple:latest   "uvicorn app.main:apâ€¦"   Up 10 seconds  0.0.0.0:80->8000/tcp
```

### 4.4 Check Container Logs

```bash
# View the application logs
docker logs fastapi-app

# You should see Uvicorn startup messages like:
# INFO:     Started server process [1]
# INFO:     Waiting for application startup.
# INFO:     Application startup complete.
# INFO:     Uvicorn running on http://0.0.0.0:8000
```

### 4.5 Test Locally on the Instance

Before testing from your browser, let's verify it works on the instance itself:

```bash
# Test the health endpoint
curl http://localhost/health

# Expected output: {"status":"healthy"}

# Test the root endpoint
curl http://localhost/

# Expected output: {"message":"Hello from FastAPI!","version":"1.0.0"}
```

If these commands return JSON responses, your app is working!

---

## Part 5: Configure Security Group and Access Your App (10 minutes)

### 5.1 Verify Security Group Rules

1. Go to **AWS Console** â†’ **EC2** â†’ **Security Groups**
2. Find your security group: `fastapi-manual-sg-{your-initials}`
3. Click on it and select the **Inbound rules** tab

**Required rules:**
- **SSH (22):** Source = Your IP (or 0.0.0.0/0 for testing)
- **HTTP (80):** Source = 0.0.0.0/0

### 5.2 Add HTTP Rule if Missing

If the HTTP rule isn't there:

1. Click **Edit inbound rules**
2. Click **Add rule**
3. Configure:
   - **Type:** HTTP
   - **Port:** 80
   - **Source:** Anywhere-IPv4 (0.0.0.0/0)
4. Click **Save rules**

### 5.3 Access Your Application from Browser

1. Get your instance's public IP from the EC2 console
2. Open your browser and navigate to:
   ```
   http://<your-instance-public-ip>
   ```

3. You should see:
   ```json
   {
     "message": "Hello from FastAPI!",
     "version": "1.0.0"
   }
   ```

4. **Test the Interactive API Documentation:**
   - Navigate to: `http://<your-instance-public-ip>/docs`
   - You'll see the FastAPI auto-generated Swagger UI
   - Test the `/` and `/health` endpoints

5. **Test All Endpoints:**
   - Root: `http://<your-instance-public-ip>/`
   - Health: `http://<your-instance-public-ip>/health`
   - API Docs: `http://<your-instance-public-ip>/docs`

---

## Part 6: Understanding Manual Deployment (5 minutes)

Congratulations! You just manually deployed an application to the cloud.

**Think about what happens if:**
- You need to deploy to 10 servers instead of 1?
- You need to update the application every week?
- The server crashes at 2 AM and needs to be recreated?
- Multiple team members need to deploy with the same steps?

**All of these scenarios are why we automate!** In later labs, you'll use Ansible and Terraform to handle all of this automatically.

### 6.1 Quick Container Operations

Here are essential Docker commands you'll need:

```bash
# View running containers
docker ps

# View logs
docker logs fastapi-app

# Restart container
docker restart fastapi-app

# Stop and start
docker stop fastapi-app
docker start fastapi-app
```

The container uses `--restart unless-stopped`, so it will survive reboots automatically.

---

## Success Criteria

You have successfully completed this lab when:

- [ ] EC2 instance is running
- [ ] Docker is installed and your user can run Docker without sudo
- [ ] FastAPI application container is running on port 80
- [ ] Application is accessible via public IP
- [ ] All API endpoints work (/, /health, /tasks, /docs)

---

## Troubleshooting

**Container not running:**
```bash
docker ps -a              # Check status
docker logs fastapi-app   # Check errors
docker restart fastapi-app
```

**Can't access from browser:**
- Check security group has port 80 open to 0.0.0.0/0
- Verify container is running: `docker ps`
- Test locally first: `curl http://localhost/health`

**Permission denied on Docker:**
```bash
groups  # Should see 'docker' in the list
# If not, you didn't log out and back in after adding to docker group
```

---

## Cleanup

### Stop the Docker Container

```bash
# Stop the running container
docker stop fastapi-app

# (Optional) Remove the container
docker rm fastapi-app
```

### Terminate EC2 Instance

1. Go to **EC2** â†’ **Instances**
2. Select your instance: `fastapi-manual-deployment-{your-initials}`
3. **Instance state** â†’ **Terminate instance**
4. Confirm termination

**Note:** Terminating the instance will permanently delete it and all data on it.

### Delete Security Group (Optional)

1. Go to **EC2** â†’ **Security Groups**
2. Select `fastapi-manual-sg-{your-initials}`
3. **Actions** â†’ **Delete security group**

**Note:** You can only delete the security group after the EC2 instance is terminated.

---

## Key Takeaways

**You manually:**
- Provisioned a cloud server
- Installed and configured Docker
- Deployed a containerized application
- Made it publicly accessible

**You experienced:**
- The repetitive nature of manual deployments
- Security configuration requirements
- Container operations and monitoring
- Why DevOps engineers love automation

**In the next lab**, you'll automate all of this using modern tools. You'll never have to SSH and run commands manually again!

---

**Congratulations!** You've deployed an application to the cloud the "classic" way. Now you're ready to learn why automation is so valuable! ðŸŽ‰
