# Automated Deployment Pipeline

## Overview

In the previous labs, you've built a complete deployment system, but there's still a manual step: after your FastAPI CI/CD pipeline builds and pushes a new Docker image, you have to manually go to the Ansible repository and trigger the deployment workflow.

Let's automate that final step! When your FastAPI CI/CD pipeline successfully pushes a new Docker image, it will automatically trigger the Ansible deployment workflow using **reusable workflows** - the modern, secure way to chain GitHub Actions.

**What You'll Build:**
- Reusable Ansible deployment workflow
- Automatic workflow calling from FastAPI CI/CD
- Complete end-to-end automation: Code push ‚Üí Build ‚Üí Deploy
- No Personal Access Tokens needed!

**‚ö†Ô∏è Important Discussion: Is This Production-Ready?**

While this approach creates a fully automated pipeline, it has some real-world limitations:
- **No deployment verification** - you're deploying code that was tested, but not verifying the deployment itself works
- **No rollback mechanism** - if deployment fails, you're stuck
- **No environment separation** - dev and prod follow same path
- **Timing issues** - Ansible might deploy before all instances pull the new image
- **No deployment gates** - no approval process for production

**When is this approach good?**
- ‚úÖ Development environments (fast feedback loop)
- ‚úÖ Internal tools (low risk)
- ‚úÖ Proof of concepts

**When is this approach risky?**
- ‚ùå Production systems (no safety nets)
- ‚ùå Critical applications (need rollback)
- ‚ùå Regulated environments (need approvals)

**Better production approaches** (covered in advanced courses):
- Blue/green deployments
- Canary releases
- Deployment verification tests
- Approval gates before production
- Rollback automation

That said, this is a great pattern for **dev environments** - let's build it!

---

## Prerequisites

- Completed Lab 1.1 (FastAPI CI/CD Pipeline)
- Completed Lab 2.2 (Ansible Deployment with GitHub Actions)
- Both pipelines working independently
- GitHub account
- Both repositories under same GitHub user/organization

---

## The Automation Flow

**Before (Manual):**
```
1. Push code to FastAPI repo
2. GitHub Actions builds Docker image
3. Image pushed to Docker Hub
4. [MANUAL] Go to Ansible repo and trigger workflow
5. Ansible deploys to instances
```

**After (Fully Automated with Reusable Workflow):**
```
1. Push code to FastAPI repo
2. FastAPI workflow: builds + pushes Docker image
3. FastAPI workflow: calls Ansible workflow as reusable workflow
4. Ansible deploys automatically
```

**Total time:** ~5-8 minutes from code push to production!

**Benefits of Reusable Workflows:**
- ‚úÖ No Personal Access Tokens needed (uses built-in GITHUB_TOKEN)
- ‚úÖ Better security (scoped permissions)
- ‚úÖ Can pass inputs between workflows
- ‚úÖ Industry standard pattern
- ‚úÖ Cleaner, more maintainable

**Risks:**
- ‚ö†Ô∏è No verification that deployment actually works
- ‚ö†Ô∏è Failed deployments require manual intervention
- ‚ö†Ô∏è All changes go straight to "production"

---

## Part 1: Make Ansible Workflow Reusable (10 minutes)

### 1.1 Update Ansible Workflow

Go to your **Ansible repository** (from Lab 2.2).

Edit `.github/workflows/deploy.yml`:

```yaml
name: Deploy with Ansible

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      docker_image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
  workflow_call:  # Makes this workflow reusable!
    inputs:
      docker_image_tag:
        description: 'Docker image tag to deploy'
        required: false
        type: string
        default: 'latest'
    secrets:
      AWS_ROLE_ARN:
        required: true

permissions:
  id-token: write  # Required for OIDC
  contents: read

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Log deployment info
        run: |
          echo "Deploying Docker image tag: ${{ inputs.docker_image_tag || 'latest' }}"
          echo "Triggered by: ${{ github.event_name }}"
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Ansible and dependencies
        run: |
          pip install ansible boto3 botocore
          ansible-galaxy collection install amazon.aws community.docker
      
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
      
      - name: Run Ansible playbook
        env:
          ANSIBLE_HOST_KEY_CHECKING: False
        run: |
          ansible-playbook playbooks/deploy.yml -i playbooks/aws_ec2.yml
      
      - name: Deployment complete
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Application is now running on all instances"
```

**Key changes:**
- Added `workflow_call` trigger - makes it reusable
- Added `inputs` to accept Docker image tag
- Added `secrets` to accept AWS role ARN
- Can still trigger manually (`workflow_dispatch`) or on push

### 1.2 Commit and Push

```bash
git add .github/workflows/deploy.yml
git commit -m "Make workflow reusable for cross-repo automation"
git push origin main
```

---

## Part 2: Update FastAPI Workflow to Call Ansible Workflow (10 minutes)

### 2.1 Add Deployment Job

Go to your **FastAPI repository** (from Lab 1.1).

Edit `.github/workflows/ci-cd.yml`:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Lint with flake8
        run: |
          pip install flake8
          flake8 app/ --count --max-line-length=127
      
      - name: Format with black
        run: |
          pip install black
          black --check app/
      
      - name: Security scan with bandit
        run: |
          pip install bandit
          bandit -r app/
      
      - name: Run tests
        run: |
          pytest tests/ -v
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/fastapi-cicd:latest
  
  deploy:
    name: Deploy to AWS
    needs: test-and-build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    uses: YOUR-USERNAME/fastapi-ansible-deploy-YOUR-INITIALS/.github/workflows/deploy.yml@main
    secrets:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
    with:
      docker_image_tag: 'latest'
```

**Replace:**
- `YOUR-USERNAME` with your GitHub username
- `YOUR-INITIALS` with your initials (matching your Ansible repo name)

**How it works:**
- `needs: test-and-build` - waits for build to finish
- `if:` condition - only deploys on main branch pushes (not PRs)
- `uses:` - calls the Ansible workflow as a reusable workflow
- `secrets:` - passes the AWS role ARN
- `with:` - passes input parameters (Docker image tag)

### 2.2 Add AWS Role ARN Secret

Your FastAPI repo needs the AWS role ARN to pass to Ansible workflow.

1. Go to your **FastAPI repository** ‚Üí **Settings** ‚Üí **Secrets and variables** ‚Üí **Actions**
2. Click **New repository secret**
3. **Name:** `AWS_ROLE_ARN`
4. **Value:** Copy the role ARN from your Ansible repository secrets (or from Lab 1.4)
   - Format: `arn:aws:iam::123456789012:role/github-oidc-role`
5. Click **Add secret**

### 2.3 Commit and Push

```bash
git add .github/workflows/ci-cd.yml
git commit -m "Add automated deployment using reusable workflow"
git push origin main
```

---

## Part 3: Test the Automation (15 minutes)

### 3.1 Make a Code Change

Go to your FastAPI application repository (from Lab 1.1).

**Edit `app/main.py`:**

```python
app = FastAPI(
    title="Task Manager API",
    description="A simple task management API for CI/CD demonstration",
    version="3.0.0"  # Increment version
)

@app.get("/")
def read_root():
    """Root endpoint returning API information"""
    return {
        "message": "Welcome to Task Manager API - Fully Automated!",
        "version": "3.0.0",
        "deployment": "Automated with reusable workflows!",
        "automation": "FastAPI calls Ansible workflow directly - no PAT needed!",
        "endpoints": ["/tasks", "/tasks/{task_id}", "/health"]
    }
```

### 3.2 Push Changes

```bash
git add app/main.py
git commit -m "Update to v3.0.0 with reusable workflow automation"
git push origin main
```

### 3.3 Watch the Complete Automation

**FastAPI CI/CD Pipeline (2-3 minutes):**
1. Go to your FastAPI repo ‚Üí **Actions**
2. Watch the "CI/CD Pipeline" workflow run
3. See two jobs:
   - **test-and-build** - runs first (lint, test, build, push)
   - **Deploy to AWS** - waits for build, then calls Ansible workflow

**Ansible Deployment (3-5 minutes):**
1. Go to your Ansible repo ‚Üí **Actions**
2. You should see "Deploy with Ansible" start automatically!
3. Notice it says "workflow_run" or shows the calling workflow
4. Watch Ansible deploy across all instances

**Verify Deployment:**
```bash
# Get your ALB URL
cd ../fastapi-terraform-infra-{your-initials}/terraform
terraform output alb_url

# Test the application
curl http://<your-alb-url>
```

You should see version 3.0.0 with the reusable workflow message!

---

## Understanding the Complete Pipeline

### The Full Automation Flow

```
Developer pushes code
        ‚Üì
FastAPI GitHub Actions (Lab 1.1)
  Job 1: test-and-build
    - Lint with flake8 & black
    - Run pytest tests
    - Build Docker image
    - Push to Docker Hub
        ‚Üì
  Job 2: deploy (waits for Job 1)
    - Calls Ansible workflow as reusable workflow
    - Passes AWS role ARN via secrets
    - Passes Docker image tag via inputs
        ‚Üì
Ansible GitHub Actions (Lab 2.2)
  - Triggered via workflow_call
  - Assumes AWS role via OIDC (Lab 1.4)
  - Discovers instances via dynamic inventory (Lab 2.1)
  - Pulls new Docker image
  - Restarts containers on all instances
        ‚Üì
Application updated in production!

Total: ~5-8 minutes, completely hands-free
```

### What You've Automated

‚úÖ **Code Quality:** Linting and testing  
‚úÖ **Build:** Docker image creation  
‚úÖ **Publish:** Push to registry  
‚úÖ **Deploy:** Updates all instances  
‚úÖ **Security:** OIDC, no stored AWS keys, no PAT needed  

**This is Continuous Deployment!**

### Advantages of Reusable Workflows

**vs Personal Access Token + curl approach:**
- ‚úÖ No token management needed
- ‚úÖ Uses built-in GITHUB_TOKEN
- ‚úÖ Better security (scoped permissions)
- ‚úÖ Can pass inputs/secrets cleanly
- ‚úÖ Easier to audit (shows in Actions UI)
- ‚úÖ Industry standard pattern
- ‚úÖ Both workflows appear in their respective repos

---

## But Remember The Limitations

‚ö†Ô∏è **What could go wrong:**
- Tests pass locally but deployment fails
- Container starts but app crashes immediately
- Database migrations break
- New code has runtime bugs not caught by tests
- All instances update at once (no canary/blue-green)

‚ö†Ô∏è **Production risks:**
- **No rollback** - if deployment breaks, manual intervention needed
- **No verification** - just assumes everything worked
- **No approval gates** - every merge goes live
- **No gradual rollout** - all instances update simultaneously

‚úÖ **Good for:**
- Development environments
- Internal tools
- Learning CI/CD concepts
- Rapid iteration

‚ùå **Not ideal for:**
- Customer-facing production
- Critical systems
- Regulated environments
- High-availability requirements

---

## Discussion: Making This Production-Ready

### Missing Pieces for Production

**1. Deployment Verification**
```yaml
# Add to Ansible playbook
- name: Wait for app to be healthy
  uri:
    url: "http://localhost:8000/health"
    status_code: 200
  retries: 5
  delay: 10
```

**2. Rollback Mechanism**
- Keep previous Docker image tag
- Ansible playbook to revert to last known good
- Automated rollback on health check failures

**3. Gradual Rollout**
- Blue/green deployment (two environments)
- Canary releases (update 10% of instances first)
- Feature flags to disable broken features

**4. Approval Gates**
```yaml
# GitHub Actions environment protection
environment:
  name: production
  url: http://your-alb-url
# Requires manual approval before deploying
```

**5. Better Testing**
- Integration tests
- End-to-end tests
- Load testing
- Security scanning

**6. Monitoring & Alerts**
- Deployment success/failure metrics
- Application error rate monitoring
- Automatic alerts to Slack/PagerDuty
- Dashboards to track deployments

### Advanced Patterns (Future Learning)

- **GitOps** (ArgoCD, FluxCD) - declarative deployments
- **Progressive Delivery** - gradual rollouts with metrics
- **Chaos Engineering** - test failure scenarios
- **Immutable Infrastructure** - never update, always replace

---

## Success Criteria

- [ ] Ansible workflow configured as reusable (`workflow_call`)
- [ ] FastAPI workflow calls Ansible workflow
- [ ] `AWS_ROLE_ARN` secret added to FastAPI repo
- [ ] Code push automatically triggers both workflows
- [ ] Deployment completes without manual intervention
- [ ] Can verify new version deployed to all instances
- [ ] No Personal Access Token needed

---

## Troubleshooting

**"Workflow must be in a public repository or in the same organization"**
- Both repos must be under same GitHub user/organization
- OR make Ansible repository public

**Deploy job doesn't start:**
- Check that `needs: test-and-build` is spelled correctly
- Verify the `if` condition matches (only on main branch, not PRs)
- Check repository path in `uses:` statement (username/repo-name)

**"Secret AWS_ROLE_ARN not found":**
- Add `AWS_ROLE_ARN` secret to FastAPI repository
- Copy value from Ansible repository secrets (or Lab 1.4)
- Ensure secret name matches exactly

**Ansible workflow fails with OIDC error:**
- Verify Lab 1.4 (OIDC setup) was completed
- Check AWS role ARN is correct format
- Ensure role trust policy includes GitHub OIDC provider

**Workflow shows "waiting":**
- Check if both repos are under same user/org
- Verify Ansible workflow file path is correct
- Ensure `workflow_call` trigger exists in Ansible workflow

**Test manually:**
```bash
# Go to FastAPI repo ‚Üí Actions
# Click "CI/CD Pipeline" workflow
# Click "Run workflow"
# Watch both jobs execute
```

---

## Cleanup

To disable automation:

**Option 1: Remove deploy job**
- Edit FastAPI `.github/workflows/ci-cd.yml`
- Delete the entire `deploy:` job

**Option 2: Add manual approval**
- Use GitHub Environments with protection rules
- Requires approval before deployment runs

**Option 3: Remove workflow_call trigger**
- Edit Ansible `.github/workflows/deploy.yml`
- Remove `workflow_call:` section (keep push and workflow_dispatch)

---

## Key Takeaways

**What You Learned:**
- Reusable workflows in GitHub Actions
- Cross-repository workflow automation
- Secure workflow triggering without PATs
- Complete CI/CD pipeline automation
- Industry-standard workflow patterns
- Production deployment considerations

**Why This Matters:**
- **Speed:** Deploy in minutes
- **Reliability:** No manual errors
- **Security:** No token management, uses GITHUB_TOKEN
- **Maintainability:** Clean, declarative approach
- **Professional:** How real companies automate deployments

**Reusable Workflows vs PAT + curl:**
- ‚úÖ No Personal Access Token needed
- ‚úÖ Better security model
- ‚úÖ Cleaner syntax
- ‚úÖ Built-in input/secret passing
- ‚úÖ Shows up properly in GitHub Actions UI
- ‚úÖ Easier to maintain and debug

---

## Additional Resources

- [GitHub Reusable Workflows Documentation](https://docs.github.com/en/actions/using-workflows/reusing-workflows)
- [Calling a Reusable Workflow](https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow)
- [Passing Secrets to Reusable Workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-secrets-to-nested-workflows)
- [GitHub Actions Best Practices](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions)

---

**Congratulations!** You've built a production-style automated deployment pipeline using modern GitHub Actions patterns! üöÄ
