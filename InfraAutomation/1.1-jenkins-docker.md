# Self-Hosted CI/CD with Jenkins

## Overview

You've built a CI/CD pipeline using GitHub Actions (cloud-hosted). Now you'll deploy your own Jenkins server and create a similar pipeline on self-hosted infrastructure.

**In this lab:**
- Deploy Jenkins on an EC2 instance using Docker
- Configure Jenkins to build Docker images
- Create a Jenkinsfile pipeline
- Automatically build and push images on code changes

**Jenkins Architecture:**
- **Controller** (formerly "master") - Manages the UI, schedules jobs, stores configuration
- **Agents** (formerly "slaves") - Execute the actual build work

In production, you'd have a controller managing multiple agents for parallel builds. For this lab, we're running a simple setup where the **controller also acts as the worker** (builds run on the same server).

**Why Jenkins?**
- Many companies use self-hosted CI/CD for security/compliance
- More control over build environment
- Useful when GitHub Actions isn't available
- Learn both cloud-hosted and self-hosted approaches

---

## Prerequisites

- Completed Lab 1.0 (GitHub Actions basics)
- AWS account access
- Docker Hub account

---

## Part 1: Deploy Jenkins on EC2 (20 minutes)

### Step 1: Launch EC2 Instance

Create a new EC2 instance in the AWS Console:
- **Instance type:** t2.medium or larger
- **Security group:** Allow SSH (22) and HTTP on port 8080 from your IP
- **Key pair:** Create or use existing

### Step 2: SSH to Your EC2 Instance

```bash
ssh -i your-key.pem ec2-user@<EC2-PUBLIC-IP>
```

### Step 2: Install Docker (if not already installed)

```bash
sudo yum update -y
sudo yum install docker -y
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -aG docker ec2-user
```

Log out and back in for group changes to take effect.

### Step 3: Run Jenkins Container

```bash
docker run -d \
  --name jenkins \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  --restart unless-stopped \
  jenkins/jenkins@sha256:7b1c378278279c8688efd6168c25a1c2723a6bd6f0420beb5ccefabee3cc3bb1
```

**Why these flags?**
- `-p 8080:8080` - Jenkins web UI
- `-p 50000:50000` - Jenkins agent communication
- `-v jenkins_home` - Persist Jenkins data
- `-v /var/run/docker.sock` - Allow Jenkins to build Docker images
- `--restart unless-stopped` - Auto-restart on reboot

### Step 4: Get Initial Admin Password

```bash
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
```

Copy this password - you'll need it in a moment.

### Step 5: Access Jenkins Web UI

1. Open your browser to: `http://<EC2-PUBLIC-IP>:8080`
2. Paste the initial admin password
3. Click **Install suggested plugins**
4. Create your admin user account
5. Click **Save and Continue** â†’ **Start using Jenkins**

**Security Note:** In production, you'd use HTTPS and proper security groups.

---

## Part 2: Create Your First Pipeline (10 minutes)

Before configuring Docker, let's understand how Jenkins pipelines work at their core.

### Step 1: Create a Simple Pipeline

1. From Jenkins dashboard, click **New Item**
2. Enter name: `hello-world-pipeline`
3. Select **Pipeline**
4. Click **OK**

### Step 2: Write a Basic Pipeline Script

1. Scroll to the **Pipeline** section
2. Set **Definition**: Pipeline script
3. Paste this code:

```groovy
pipeline {
    agent any
    
    stages {
        stage('Hello') {
            steps {
                echo 'Hello World!'
            }
        }
        
        stage('Hello with Shell') {
            steps {
                sh 'echo "Hello from shell!"'
            }
        }
    }
}
```

4. Click **Save**

### Step 3: Run the Pipeline

1. Click **Build Now**
2. Click on the build number â†’ **Console Output**

**Observe:**
- `echo 'Hello World!'` - Jenkins native command (doesn't use shell)
- `sh 'echo "Hello from shell!"'` - Executes actual shell command

### Step 4: Understanding the Difference

Try adding this stage to see what's really happening:

```groovy
stage('Show Environment') {
    steps {
        sh 'whoami'
        sh 'pwd'
        sh 'echo $SHELL'
    }
}
```

**Key Insight:** 
The `sh` step runs commands in a shell (`/bin/sh`). When you use Jenkins plugins (like Docker Pipeline's `docker.build()`), they're actually **abstractions that execute shell commands behind the scenes**. The plugins provide a cleaner Groovy DSL (Domain-Specific Language - a specialized syntax for a specific task), but ultimately they're running `docker build`, `docker push`, etc. in a shell.

This is why we needed to install the Docker CLI - the Docker Pipeline plugin needs the `docker` command available in the shell.

---

## Part 3: Configure Jenkins for Docker (15 minutes)

Now that you understand how pipelines execute commands, let's set up Docker.

### Step 1: Install Docker Plugins

1. Go to **Manage Jenkins** â†’ **Plugins**
2. Click **Available plugins**
3. Search for and install:
   - **Docker Pipeline**
   - **Docker** (Docker plugin)
4. Click **Install** and restart Jenkins if prompted

Wait for Jenkins to restart (~30 seconds).

### Step 2: Install Docker CLI in Jenkins Container

The Docker plugins need the Docker CLI to execute commands:

```bash
docker exec -u root jenkins bash -c "
  curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-27.4.1.tgz | tar xz -C /usr/local/bin --strip-components=1 docker/docker
"

docker restart jenkins
```

Wait for Jenkins to restart (~30 seconds).

### Step 3: Fix Docker Socket Permissions

Allow Jenkins to access the Docker daemon socket:

```bash
docker exec -u root jenkins chmod 666 /var/run/docker.sock
```

**Note:** This makes the socket accessible to all users in the container. In production, you'd add the jenkins user to the docker group on the host instead.

### Step 4: Add Docker Hub Credentials

1. In Jenkins, go to **Manage Jenkins** â†’ **Credentials**
2. Click **(global)** â†’ **Add Credentials**
3. Fill in:
   - **Kind**: Username with password
   - **Username**: Your Docker Hub username
   - **Password**: Your Docker Hub password (or access token)
   - **ID**: `dockerhub-credentials`
   - **Description**: Docker Hub Login
4. Click **Create**

---

## Part 4: Create Application Repository (10 minutes)

### Step 1: Create New GitHub Repository

Create a new public GitHub repository called `jenkins-demo-app` (separate from your GitOps lab).

### Step 2: Create Application Files

Clone the repository locally and create these files:

**`app.py`:**
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from Jenkins CI/CD!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

**`Dockerfile`:**
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY app.py .
RUN pip install flask
EXPOSE 8080
CMD ["python", "app.py"]
```

**`Jenkinsfile`:**
```groovy
pipeline {
    agent any
    
    environment {
        IMAGE_NAME = "YOUR_DOCKERHUB_USERNAME/jenkins-demo-app"
    }
    
    stages {
        stage('Build Docker Image') {
            steps {
                script {
                    // Use Docker Pipeline plugin to build image
                    dockerImage = docker.build("${IMAGE_NAME}:${BUILD_NUMBER}")
                }
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                script {
                    // Use Docker Pipeline plugin to push with credentials
                    docker.withRegistry('https://registry.hub.docker.com', 'dockerhub-credentials') {
                        dockerImage.push("${BUILD_NUMBER}")
                        dockerImage.push("latest")
                    }
                }
            }
        }
    }
    
    post {
        success {
            echo "Pipeline succeeded! Image pushed: ${IMAGE_NAME}:${BUILD_NUMBER}"
        }
        failure {
            echo "Pipeline failed!"
        }
    }
}
```

**Important:** Replace `YOUR_DOCKERHUB_USERNAME` with your actual Docker Hub username!

### Step 3: Commit and Push

```bash
git add .
git commit -m "Initial Jenkins pipeline"
git push origin main
```

---

## Part 5: Create Jenkins Pipeline (15 minutes)

### Step 1: Create New Pipeline Job

1. From Jenkins dashboard, click **New Item**
2. Enter name: `jenkins-demo-app`
3. Select **Pipeline**
4. Click **OK**

### Step 2: Configure Pipeline

1. Scroll to **Pipeline** section
2. Set **Definition**: Pipeline script from SCM
3. Set **SCM**: Git
4. Set **Repository URL**: `https://github.com/YOUR_USERNAME/jenkins-demo-app.git`
5. Set **Branch**: `*/main`
6. Set **Script Path**: `Jenkinsfile`
7. Click **Save**

**Note:** Since we're using a public repository, Jenkins can clone it without credentials. For private repositories, you'd need to add GitHub credentials (SSH key or Personal Access Token) in **Manage Jenkins** â†’ **Credentials**.

### Step 3: Run Your First Build

1. Click **Build Now**
2. Watch the build progress in **Build History**
3. Click on the build number â†’ **Console Output** to see logs

**What to observe:**
- Git checkout
- Docker image build
- Docker login
- Image push to Docker Hub
- Cleanup

### Step 4: Verify on Docker Hub

Go to Docker Hub and verify your `jenkins-demo-app` repository has a new image with build number tag.

---

## Part 6: Automate Builds (15 minutes)

### Step 1: GitHub Webhook (Better)

1. In Jenkins, go to your pipeline â†’ **Configure**
2. Under **Build Triggers**, check **GitHub hook trigger for GITScm polling**
3. Click **Save**

4. In GitHub, go to your `jenkins-demo-app` repository â†’ **Settings** â†’ **Webhooks**
5. Click **Add webhook**
6. Set:
   - **Payload URL**: `http://<EC2-PUBLIC-IP>:8080/github-webhook/`
   - **Content type**: application/json
   - **Events**: Just the push event
7. Click **Add webhook**

**Note:** This requires Jenkins to be publicly accessible. In production, use a reverse proxy with HTTPS.

### Step 2: Test Automatic Build

1. Modify `app.py` locally:

2. Commit and push:
```bash
git add app.py
git commit -m "Update message"
git push origin main
```

3. Watch Jenkins automatically trigger a build!

---

## Part 7: Compare Jenkins vs GitHub Actions

### Discussion Questions

**1. What are the differences you noticed?**

| Feature | GitHub Actions | Jenkins |
|---------|---------------|---------|
| Hosting | Cloud (GitHub-hosted) | Self-hosted (your EC2) |
| Setup | No setup needed | Install & configure |
| Syntax | YAML | Groovy (Jenkinsfile) |
| Runners | Provided by GitHub | You manage the server |
| Cost | Free tier, then pay | You pay for EC2 |
| Secrets | GitHub Secrets | Jenkins Credentials |

**2. When would you use Jenkins?**
- Need full control over build environment
- Security/compliance requires on-prem CI/CD
- Already have Jenkins infrastructure
- Need advanced features (complex pipelines, plugins)

**3. When would you use GitHub Actions?**
- Simpler setup and maintenance
- GitHub-native integration
- Don't want to manage servers
- Want fast, scalable runners

---

## Part 8: Bonus Challenges (Optional)

### Bonus 1: Parameterized Builds

Allow custom image tags:

1. Configure pipeline â†’ **This project is parameterized**
2. Add **String Parameter**: `IMAGE_TAG` with default `latest`
3. Update Jenkinsfile to use `${params.IMAGE_TAG}` instead of `${BUILD_NUMBER}`

### Bonus 2: Multi-Stage Pipeline with Testing

Add a testing stage that runs **before** building the Docker image. If tests fail, the pipeline should stop and not build/push the image.

**Tips:**
- Add a new `stage('Test')` before the build stage
- You can run Python tests directly on the Jenkins agent (install python packages if needed)
- Or create a separate test Dockerfile and run tests in a container
- Use proper stage ordering - tests should come before builds
- The pipeline will automatically stop if a stage fails

**Think about:**
- What happens if tests fail? Should you still build the image?
- How do you ensure the code is tested before it's packaged?
- Can you run tests without building the full application image?

### Bonus 3: Run Your Application

Clean up Jenkins to free resources and run the Flask app you just built:

```bash
# Stop and remove Jenkins container
docker stop jenkins
docker rm jenkins

# Remove Jenkins image
docker rmi jenkins/jenkins@sha256:7b1c378278279c8688efd6168c25a1c2723a6bd6f0420beb5ccefabee3cc3bb1

# Run your application
docker run -d --name my-app -p 8080:8080 YOUR_DOCKERHUB_USERNAME/jenkins-demo-app:latest

# Test it
curl http://localhost:8080
```

Visit `http://<EC2-PUBLIC-IP>:8080` to see your app running!

---

## Cleanup

Terminate your EC2 instance in the AWS Console when you're done.

---

## Success Criteria

- [ ] Jenkins running on EC2
- [ ] Jenkins successfully builds Docker images
- [ ] Images pushed to Docker Hub with build numbers
- [ ] Pipeline triggered automatically on Git push
- [ ] Understand differences between Jenkins and GitHub Actions

---

## Key Takeaways

**Self-Hosted CI/CD:**
- More control but more responsibility
- You manage updates, security, scaling
- Useful for compliance or legacy systems

**Jenkins Pipelines:**
- Groovy-based (different from YAML)
- Powerful plugin ecosystem
- Widely used in enterprise

**Docker-in-Docker:**
- Jenkins container can build Docker images
- Requires mounting Docker socket
- Security considerations in production

**Comparison:**
- GitHub Actions: Easy, scalable, cloud-native
- Jenkins: Flexible, self-hosted, established

**Next:** You now know both cloud-hosted and self-hosted CI/CD! In later labs, you'll use GitHub Actions for the GitOps pipeline, but you could just as easily use Jenkins.

---

**Great work!** You've successfully deployed Jenkins and built a complete CI/CD pipeline on your own infrastructure! ðŸš€
