# Self-Hosted CI/CD with Jenkins

## Overview

You've built a CI/CD pipeline using GitHub Actions (cloud-hosted). Now you'll deploy your own Jenkins server and create a similar pipeline on self-hosted infrastructure.

**In this lab:**
- Deploy Jenkins on an EC2 instance using Docker
- Configure Jenkins to build Docker images
- Create a Jenkinsfile pipeline
- Automatically build and push images on code changes

**Why Jenkins?**
- Many companies use self-hosted CI/CD for security/compliance
- More control over build environment
- Useful when GitHub Actions isn't available
- Learn both cloud-hosted and self-hosted approaches

---

## Prerequisites

- Completed Lab 1.0 (GitHub Actions basics)
- EC2 instance running (t2.medium or larger recommended)
- SSH access to your EC2 instance
- Docker Hub account

---

## Part 1: Deploy Jenkins on EC2 (20 minutes)

### Step 1: SSH to Your EC2 Instance

```bash
ssh -i your-key.pem ec2-user@<EC2-PUBLIC-IP>
```

### Step 2: Install Docker (if not already installed)

```bash
sudo yum update -y
sudo yum install docker -y
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -aG docker ec2-user
```

Log out and back in for group changes to take effect.

### Step 3: Run Jenkins Container

```bash
docker run -d \
  --name jenkins \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  --restart unless-stopped \
  jenkins/jenkins:lts
```

**Why these flags?**
- `-p 8080:8080` - Jenkins web UI
- `-p 50000:50000` - Jenkins agent communication
- `-v jenkins_home` - Persist Jenkins data
- `-v /var/run/docker.sock` - Allow Jenkins to build Docker images
- `--restart unless-stopped` - Auto-restart on reboot

### Step 4: Get Initial Admin Password

```bash
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
```

Copy this password - you'll need it in a moment.

### Step 5: Access Jenkins Web UI

1. Open your browser to: `http://<EC2-PUBLIC-IP>:8080`
2. Paste the initial admin password
3. Click **Install suggested plugins**
4. Create your admin user account
5. Click **Save and Continue** â†’ **Start using Jenkins**

**Security Note:** In production, you'd use HTTPS and proper security groups. For this lab, ensure port 8080 is only open to your IP.

---

## Part 2: Configure Jenkins for Docker (15 minutes)

### Step 1: Install Docker Inside Jenkins Container

Jenkins needs Docker CLI to build images:

```bash
docker exec -u root jenkins bash -c "
  apt-get update && \
  apt-get install -y docker.io && \
  usermod -aG docker jenkins
"

# Restart Jenkins to apply group changes
docker restart jenkins
```

Wait ~30 seconds for Jenkins to restart.

### Step 2: Add Docker Hub Credentials

1. In Jenkins, go to **Manage Jenkins** â†’ **Credentials**
2. Click **(global)** â†’ **Add Credentials**
3. Fill in:
   - **Kind**: Username with password
   - **Username**: Your Docker Hub username
   - **Password**: Your Docker Hub password (or access token)
   - **ID**: `dockerhub-credentials`
   - **Description**: Docker Hub Login
4. Click **Create**

### Step 3: Install Required Plugins

1. Go to **Manage Jenkins** â†’ **Plugins**
2. Click **Available plugins**
3. Search for and install:
   - **Docker Pipeline** (if not already installed)
   - **Git** (should already be installed)
4. Click **Install** and restart if prompted

---

## Part 3: Create Application Repository (10 minutes)

### Step 1: Create New GitHub Repository

Create a new repository called `jenkins-demo-app` (separate from your GitOps lab).

### Step 2: Create Application Files

Clone the repository locally and create these files:

**`app.py`:**
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from Jenkins CI/CD!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

**`Dockerfile`:**
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY app.py .
RUN pip install flask
EXPOSE 8080
CMD ["python", "app.py"]
```

**`Jenkinsfile`:**
```groovy
pipeline {
    agent any
    
    environment {
        DOCKERHUB_CREDENTIALS = credentials('dockerhub-credentials')
        IMAGE_NAME = "YOUR_DOCKERHUB_USERNAME/jenkins-demo-app"
        IMAGE_TAG = "${BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/YOUR_USERNAME/jenkins-demo-app.git'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    sh "docker build -t ${IMAGE_NAME}:${IMAGE_TAG} ."
                    sh "docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:latest"
                }
            }
        }
        
        stage('Login to Docker Hub') {
            steps {
                sh 'echo $DOCKERHUB_CREDENTIALS_PSW | docker login -u $DOCKERHUB_CREDENTIALS_USR --password-stdin'
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                script {
                    sh "docker push ${IMAGE_NAME}:${IMAGE_TAG}"
                    sh "docker push ${IMAGE_NAME}:latest"
                }
            }
        }
        
        stage('Cleanup') {
            steps {
                sh "docker rmi ${IMAGE_NAME}:${IMAGE_TAG}"
                sh "docker rmi ${IMAGE_NAME}:latest"
            }
        }
    }
    
    post {
        always {
            sh 'docker logout'
        }
        success {
            echo "Pipeline succeeded! Image pushed: ${IMAGE_NAME}:${IMAGE_TAG}"
        }
        failure {
            echo "Pipeline failed!"
        }
    }
}
```

**Important:** Replace `YOUR_DOCKERHUB_USERNAME` and `YOUR_USERNAME` with your actual usernames!

### Step 3: Commit and Push

```bash
git add .
git commit -m "Initial Jenkins pipeline"
git push origin main
```

---

## Part 4: Create Jenkins Pipeline (15 minutes)

### Step 1: Create New Pipeline Job

1. From Jenkins dashboard, click **New Item**
2. Enter name: `jenkins-demo-app`
3. Select **Pipeline**
4. Click **OK**

### Step 2: Configure Pipeline

1. Scroll to **Pipeline** section
2. Set **Definition**: Pipeline script from SCM
3. Set **SCM**: Git
4. Set **Repository URL**: `https://github.com/YOUR_USERNAME/jenkins-demo-app.git`
5. Set **Branch**: `*/main`
6. Set **Script Path**: `Jenkinsfile`
7. Click **Save**

### Step 3: Run Your First Build

1. Click **Build Now**
2. Watch the build progress in **Build History**
3. Click on the build number â†’ **Console Output** to see logs

**What to observe:**
- Git checkout
- Docker image build
- Docker login
- Image push to Docker Hub
- Cleanup

### Step 4: Verify on Docker Hub

Go to Docker Hub and verify your `jenkins-demo-app` repository has a new image with build number tag.

---

## Part 5: Automate Builds (15 minutes)

### Option 1: Poll SCM (Simple)

1. Go to your pipeline job â†’ **Configure**
2. Under **Build Triggers**, check **Poll SCM**
3. Set schedule: `H/5 * * * *` (poll every 5 minutes)
4. Click **Save**

Now Jenkins checks GitHub every 5 minutes for changes.

### Option 2: GitHub Webhook (Better)

1. In Jenkins, go to your pipeline â†’ **Configure**
2. Under **Build Triggers**, check **GitHub hook trigger for GITScm polling**
3. Click **Save**

4. In GitHub, go to your `jenkins-demo-app` repository â†’ **Settings** â†’ **Webhooks**
5. Click **Add webhook**
6. Set:
   - **Payload URL**: `http://<EC2-PUBLIC-IP>:8080/github-webhook/`
   - **Content type**: application/json
   - **Events**: Just the push event
7. Click **Add webhook**

**Note:** This requires Jenkins to be publicly accessible. In production, use a reverse proxy with HTTPS.

### Step 6: Test Automatic Build

1. Modify `app.py` locally:
```python
return 'Hello from Jenkins CI/CD - Version 2!'
```

2. Commit and push:
```bash
git add app.py
git commit -m "Update message"
git push origin main
```

3. Watch Jenkins automatically trigger a build!

---

## Part 6: Compare Jenkins vs GitHub Actions

### Discussion Questions

**1. What are the differences you noticed?**

| Feature | GitHub Actions | Jenkins |
|---------|---------------|---------|
| Hosting | Cloud (GitHub-hosted) | Self-hosted (your EC2) |
| Setup | No setup needed | Install & configure |
| Syntax | YAML | Groovy (Jenkinsfile) |
| Runners | Provided by GitHub | You manage the server |
| Cost | Free tier, then pay | You pay for EC2 |
| Secrets | GitHub Secrets | Jenkins Credentials |

**2. When would you use Jenkins?**
- Need full control over build environment
- Security/compliance requires on-prem CI/CD
- Already have Jenkins infrastructure
- Need advanced features (complex pipelines, plugins)

**3. When would you use GitHub Actions?**
- Simpler setup and maintenance
- GitHub-native integration
- Don't want to manage servers
- Want fast, scalable runners

---

## Part 7: Bonus Challenges (Optional)

### Bonus 1: Multi-Stage Pipeline

Add a test stage to your Jenkinsfile:

```groovy
stage('Test') {
    steps {
        script {
            sh "docker run --rm ${IMAGE_NAME}:${IMAGE_TAG} python -c 'import app; print(\"Tests passed!\")'"
        }
    }
}
```

### Bonus 2: Parameterized Builds

Allow custom image tags:

1. Configure pipeline â†’ **This project is parameterized**
2. Add **String Parameter**: `IMAGE_TAG` with default `latest`
3. Update Jenkinsfile to use `${params.IMAGE_TAG}`

### Bonus 3: Deploy After Build

Add a deployment stage that runs the container on the same EC2:

```groovy
stage('Deploy') {
    steps {
        script {
            sh "docker stop jenkins-app || true"
            sh "docker rm jenkins-app || true"
            sh "docker run -d --name jenkins-app -p 8081:8080 ${IMAGE_NAME}:${IMAGE_TAG}"
        }
    }
}
```

Test it: `http://<EC2-IP>:8081`

---

## Cleanup

When you're done with the lab:

```bash
# Stop and remove Jenkins
docker stop jenkins
docker rm jenkins

# Remove Jenkins data (optional)
docker volume rm jenkins_home

# Remove demo app images
docker rmi YOUR_USERNAME/jenkins-demo-app:latest
```

---

## Success Criteria

- [ ] Jenkins running on EC2
- [ ] Jenkins successfully builds Docker images
- [ ] Images pushed to Docker Hub with build numbers
- [ ] Pipeline triggered automatically on Git push
- [ ] Understand differences between Jenkins and GitHub Actions

---

## Key Takeaways

**Self-Hosted CI/CD:**
- More control but more responsibility
- You manage updates, security, scaling
- Useful for compliance or legacy systems

**Jenkins Pipelines:**
- Groovy-based (different from YAML)
- Powerful plugin ecosystem
- Widely used in enterprise

**Docker-in-Docker:**
- Jenkins container can build Docker images
- Requires mounting Docker socket
- Security considerations in production

**Comparison:**
- GitHub Actions: Easy, scalable, cloud-native
- Jenkins: Flexible, self-hosted, established

**Next:** You now know both cloud-hosted and self-hosted CI/CD! In later labs, you'll use GitHub Actions for the GitOps pipeline, but you could just as easily use Jenkins.

---

**Great work!** You've successfully deployed Jenkins and built a complete CI/CD pipeline on your own infrastructure! ðŸš€
